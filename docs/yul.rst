.. _yul:

###
یول
###

.. index:: ! assembly, ! asm, ! evmasm, ! yul, julia, iulia

یول ( قبلا جولیا (JULIA) یا یولیا (IULIA) نام داشت) 
یک زبان میانی کامپایل شده به بایت کد(bytecode) است که برای بک اند (backend) های مختلف بکار می رود.

برای پشتیبانی از EVM 1.0 ، EVM1.5  و Ewasm برنامه ریزی شده است، برای استفاده کلی
در تمامی پلتفرم ها طراحی شده است. در حال حاضر بصورت جداگانه و هم در داخل سالیدیتی
با عنوان “inline assembly” قابل استفاده است و کامپایلر سالیدیتی از یک پیاده سازی تجربی
بنام یول به عنوان زبان میانی استفاده می کند. یول گزینه خوبی برا بهینه سازی است که این
بهینه سازی در تمامی پلتفرم های هدف بصورت یکسان عمل می کند.

انگیزه و شرح سطح-بالا
========================

طراحی یول به چندین هدف تلاش می کند برسد:

1. برنامه هایی که توسط یول نوشته می شوند باید خوانایی داشته باشند، حتی اگر کد توسط کامپایلر سالیدیتی یا دیگر زبان های برنامه نویسی سطح-بالا تولید شده باشد.
2. کنترل جریان برنامه باید به آسانی باشد تا به بررسی دستی ، راستی آزمایی رسمی و بهینه سازی  کمک کند.
3. ترجمه از یول به بایت کد(bytecode) حدالامکان باید راحت باشد.
4. یول باید برای بهینه سازی کل-برنامه مناسب باشد.

به ترتیب برای رسیدن به هدف های شماره اول و دوم، یول ساختار های برنامه نویسی سطح بالا مثل 
``for`` ، ``if``  و ``switch`` و فراخوانی توابع را فراهم می کند. اینها برای نمایش کنترل جریان برای
برنامه های اسمبلی مناسب و کافی است .بنابرین صراحتا نیازی به بیانیه های ``SWAP`` ، ``DUP`` ،  ``JUMPDEST`` ، ``JUMP`` و ``JUMPI`` 
نیست چون دوتای اول در کنترل داده و دوتای دوم در کنترل جریان گیج کننده هستند.علاوه بر این بیانیه های توابع به شکل 
``mul(add(x, y), 7)`` از حالت خالصش که شبیه ``7 y x add mul`` مقبولتر است چون در حالت اول خیلی راحت می توان
تشخیص داد که کدام عملوند با کدام عملگر استفاده شده است.

حتی مستقیما برای ماشین های پشته ای (stack machine) طراحی شده است ، یول به خودی خود پیچیدگی های زیادی تحمیل پشته نمی کند. برنامه نویس 
یا نویسنده نباید زیاد نگران پشته باشد.

هدف سوم بصورت طبیعی با کامپایل ساختار های زبان برنامه نویسی سطح بالا به بایت کد
(bytecode) تحقق می یابد. تنها عملیاتی که بصورت غیر محلی توسط اسمبلر انجام می شود، تبدیل نام شناسه های مشخص شده خود
کاربر(توابع ، متغیر ها ، ... ) و پاکسازی متغیر های محلی از پشته است.

برای جلوگیری تداخل مفهوم بین مقادیر و منابع ، یول بصورت ایستا مقداردهی می شود.
همچنین انواع متغیر پیش فرض(معمولا کلمه ای صحیح(integer) از ماشین هدف)  همیشه می
توانند به خوانایی برنامه کمک کنند.

برای نگهداری ساده و انعطاف پذیری زبان یول به شکل خام عملگر ازپیش-ساخته داخلی ، توابع
یا متغیرهای متنوع ندارد.وقتی می خواهیم گویش یول را مشخص کنیم، این قابلیت ها به همراه
مفاهیمشان اضافه می شوند که به یول تخصص می دهند به نیاز ها و سلسله قابلیت های پلتفرم
های مختلف جواب دهد.

در حال حاضر ، فقط یک نوع گویش یول مشخص شده است. این گویش از کد گزاری EVM
بصورت توابع داخلی( به پایین نگاه کنید) و فقط نوع ``u256`` تعریف شده بر پایه نوع خالم 256
بیتی EVM است استفاده می کند.به همین دلیل ما نوع متغیر ها را در مثال زیر فراهم نخواهیم
کرد.


مثال ساده
===========

برنامه مثال ذیل طبق گویش EVM نوشته شده و بصورت نمایی محاسبه می شود.با استفاده از
``solc --strict-assembly`` می توان کامپایل کرد. توابع داخلی ``mul`` و ``div`` به ترتیب عمل ضرب
و تقسیم را انجام می دهند.

.. code-block:: yul

    {
        function power(base, exponent) -> result
        {
            switch exponent
            case 0 { result := 1 }
            case 1 { result := base }
            default
            {
                result := power(mul(base, base), div(exponent, 2))
                switch mod(exponent, 2)
                    case 1 { result := mul(base, result) }
            }
        }
    }

همچنین می توان بجای تابع برگشتی از یک حلقه for استفاده کرد. اینجا ``lt(a, b)`` زمانی اجرا
می شوند که ``a``  کوچکتر از ``b``  باشد. مقایسه کوچکتر-از

.. code-block:: yul

    {
        function power(base, exponent) -> result
        {
            result := 1
            for { let i := 0 } lt(i, exponent) { i := add(i, 1) }
            {
                result := mul(result, base)
            }
        }
    }

:ref:`در آخر بخش  <erc20yul>` ، مراحل کامل پیاده سازی استاندارد ERC-20 می توانید پیدا کنید.



استفاده مستقل
===============

شما از یول بصورت مستقل به شکل گویش EVM با کامپایلر سالیدیتی می توانید استفاده کنید.
از کدینگ شی ای یول :ref:`Yul object notation <yul-object>` استفاده خواهد شد این امکان وجود دارد که کد
را به داده ارجاع داد و به عنوان قرارداد بارگذاری کرد. این یول توسط خط فرمان کامپایلر ( از
``strict-assembly--`` استفاده کنید) و برای :ref:`رابط-استاندارد جیسون <compiler-api>` در دسترس است:

.. code-block:: json

    {
        "language": "Yul",
        "sources": { "input.yul": { "content": "{ sstore(0, 1) }" } },
        "settings": {
            "outputSelection": { "*": { "*": ["*"], "": [ "*" ] } },
            "optimizer": { "enabled": true, "details": { "yul": true } }
        }
    }

.. warning::

    یول در حال توسعه فعال است و تولید بایت کد فقط دربستر EVM و با گویش یول در EVM 1.0 پیاده سازی شده است.


توضیحات غیر رسمی از یول
===========================

در ادامه ، از جنبه های مختلف زبان یول صحبت خواهیم کرد . در مثال ها از گویش پیش قرض EVM استفاده خواهیم کرد.

نحوه نوشتاری
--------------

یول حرف ها، توضیحات و شناسه ها را مثل سالیدیتی می خواند. بنابراین شما می توانید از ``//`` و
``/* */`` برای مشخص کردن توضیحات استفاده کنید.اشتثایی وجود ندارد شناسه ها در یول می
توانند نقطه داشته باشند : ``.`` .

یول می تواند "شی ها" را که شامل کد و داده ها و زیر- شی ها هشتند مشخص کند.
لطفا از بخش شی های یول :ref:`Yul Objects <yul-object>` برای جزئیات بیشتر از بخش پایین دیدن کنید.
در این بخش ما فقط کد را بخشی از یک شی مصوب می کنیم.
این تکنه کد همیشه شامل یک بلوک جدا کننده از آکولاد ها است.
بیشتر ابزار ها بجای یک شی فقط کد را مشخص می کنند.

داخل یک بلوک کد، عناصر زیر قابل استفاده هستند 
( بخش بعدی را برای کسب جزئیات بیشتر نگاه کنید):

- حرف ها مثل : ``0x123`` ،  ``42`` یا ``“abc”`` (رشته ها تا 32 کاراکتر)
- فراخوانی های توابع داخلی مثل: ``add(1, mload(0))``
- تعریف های متغیر مثل : ``let x := 7`` , ``let x := add(y, 3)`` یا ``let x`` (مقدار اولیه صفر داده می شود)
- شناسه ها (متغیر ها) مثل : ``add(3, x)``
- انتساباتات مثل : ``x := add(y,3)``
- بلوک هایی که متغیر ها درمحدوده داخلی هشتند مثل: ``{ let x := 3 { let y := add(x, 1) } }``
- بیانیه if  مثل : ``if lt(a, b) { sstore(0, 1) }``
- بیانیه switch مثل : ``switch mload(0) case 0 { revert() } default { mstore(0, 1) }``
- چرخه for loop مثل : ``for { let i := 0} lt(i, 10) { i := add(i, 1) } { mstore(i, 7) }``
- تعاریف تابع مثل : ``function f(a, b) -> c { c := add(a, b) }```

عناصر می توانند همدیگر را دنبال کنند و توسط فاصله (فضای خالی) از هم جدا شوند،
 نیازی به کاراکتر اتمام خط مثل ``;`` و یا سطر جدید نیست.

حروف 
--------

به عنوان حروف شما می توانید استفاده کنید از:

- ثابت های عددی که می توانند در مبنای ده دهی و شانزدهی باشند.

- رشته هاس اسکی (مثل ``"abc"``), که می توانند شامل کدهای مبنای شانزده باشند ``xNN/`` و کد های یونیکد ``uNNNN/`` که در آن ``N`` اعداد در مبنای شانزده هستند.

- رشته های هگزادسیمال (مثل ``hex"616263"``).

In the EVM dialect of Yul, literals represent 256-bit words as follows:

- Decimal or hexadecimal constants must be less than ``2**256``.
  They represent the 256-bit word with that value as an unsigned integer in big endian encoding.

- An ASCII string is first viewed as a byte sequence, by viewing
  a non-escape ASCII character as a single byte whose value is the ASCII code,
  an escape ``\xNN`` as single byte with that value, and
  an escape ``\uNNNN`` as the UTF-8 sequence of bytes for that code point.
  The byte sequence must not exceed 32 bytes.
  The byte sequence is padded with zeros on the right to reach 32 bytes in length;
  in other words, the string is stored left-aligned.
  The padded byte sequence represents a 256-bit word whose most significant 8 bits are the ones from the first byte,
  i.e. the bytes are interpreted in big endian form.

- A hex string is first viewed as a byte sequence, by viewing
  each pair of contiguous hex digits as a byte.
  The byte sequence must not exceed 32 bytes (i.e. 64 hex digits), and is treated as above.

هنگام کامپایل در EVM، این به دستور ``PUSHi`` مناسب ترجمه خواهد شد. در مثال ذیل ، ``3`` و ``2``
جمع شده  نیجه 5 با رشته “abc”  بصورت بیتی با هم ``and`` می شوند. مقدار نهایی به متغیر
محلی بنام ``x``  انتساب می شود.

رشته ها بصورت چپ چین قرار می گیرند و اندازه آنها نمی تواند بیشتر از 32 بایت باشد. این
محدودیت به رشته هایی که به عنوان ورودی به توابعی که ورودی آنها رشته می پذیرد شامل
نیست.(مثل : ``setimmutable``  یا ``loadimmutable``)  . محدودیت آن رشته ها در بایت کد به پایان نمی رسد.

.. code-block:: yul

    let x := and("abc", add(3, 2))

همیشه از نوع پیش فرض است ، مگر اینکه بعد از دونقطه روی هم (:) نوع آن را مشخص کنید.

.. code-block:: yul

    // This will not compile (u32 and u256 type not implemented yet)
    let x := and("abc":u32, add(3:u256, 2:u256))


فراخوانی های توابع 
------------------

هم توابع داخلی و هم توابع تعریف شده توسط کاربر (به پایین نگاه کنید) می توانند به یک روش
فراخوانی شوند همان طور که در مثال قبل دید. اگر تابع یک مقدار بر گرداند، می توان داخل یک
عبارت دوباره از آن استفاده کرد. اگر چند مقدار برگرداند باید از یک متغیر محلی استفاده کرد.

.. code-block:: yul

    function f(x, y) -> a, b { /* ... */ }
    mstore(0x80, add(mload(0x80), 3))
    // Here, the user-defined function `f` returns two values.
    let x, y := f(1, mload(0))

برای توابع داخلی EVM، عبارات عملکردی می توانند مستقیما به یک رشته ای از کد گذاری
ترجمه شوند: شما فقط برای بدست آوردن کد کذاری از راست به چپ عبارات را می خوانید.
در مورد اولین خط مثال : ``PUSH1 3 PUSH1 0x80 MLOAD ADD PUSH1 0x80 MSTORE``.

برای فراخوانی های توابع تعریف شده کاربر، مقادیر وروردی داخل پشته از راست به چپ داخل
پشته قرار می گیرند این ترتیب ارزیابی لیست های وروردی است. مقادیر برگشتی، انتظار می
رود از چپ به راست در پشته قرار گیرند. یعنی در این مثال ``y`` در بالای پشته است و ``x`` زیر آن.

تعاریف متغیر
------------

برای تعریف متغیر ها می توانید از کلمه کلیدی ``let`` استفاده کنید. یک متغیر فقط در داخل بلوکی
که تعریف شده ``{...}`` قابل مشاهده است. هنگام کامپایل به EVM، اسلات پشته جدید ایجاد می
شود که مختص متغیر است و با رسیدن به انتهای بلوک خودکار دوباره  از بین می رود. می
توانید مقدار اولیه ای برای متغیر ارائه دهید. اگر مقداری ارائه ندهدید، مقدار متغیر صفر در نظر
گرفته می شود.

از آنجایی که متغیر ها روی پشته ذخیره می شوند، مستقیما بر حافظه یا هارد تاثیر نمی گذارند،
اما می توان از آنها به عنوان اشاره گر ها در حافظه و یا مکان های ذخیره سازی در توابع داخلی
``mstore`` , ``mload`` , ``sstore`` و ``sload`` استفاده کرد.گویش های آینده ممکن است نوع های(
types) خاصی را برای این اشاره گر ها معرفی کند.

وقتی یک متغیر ارجاع می شود، مقدار فعلی آن کپی می شود. برای EVM ، این به یک دستور ``DUP`` ترجمه می شود.

.. code-block:: yul

    {
        let zero := 0
        let v := calldataload(zero)
        {
            let y := add(sload(v), 1)
            v := y
        } // y is "deallocated" here
        sstore(v, zero)
    } // v and zero are "deallocated" here


اگر متغیر تعریف شده نوع متفاوتی از نوع ئیش فرض داشته باشد، شما این را به دونقطه روی
هم نشان می دهید. هنگامی که از یک فراخوانی تابعی که چندین مقدار بر می گرداند، می توانید
متغیر های مختلفی را دریک عبارت تعریف کنید.

.. code-block:: yul

    // This will not compile (u32 and u256 type not implemented yet)
    {
        let zero:u32 := 0:u32
        let v:u256, t:u32 := f()
        let x, y := g()
    }

بسته به تنظیمات بهینه ساز، پس از استفاده از متغیر برای آخرین بار ، کامپایلر می تواند اسلات
پشته را از قبل آزاد کند، حتی اگر هنوز در محدوده باشد.


انتسابات
-----------

متغیر ها را می توان پس از تعریف با استفاده از عملگر ``:=`` نسبت داد. انتساب همزمان چندین
متغیر امکان پذیر است. برای این کار، تعداد و انواع مقادیر باید مطابقت داشته باشند.اگر می
خواهید مقادیر برگشتی از تابعی را که دارای پارامتر های باز گشتی متعدد است اختصاص دهید،
باید متغیر های متعددی را فراهم کنید. متغیری ممکن نیست چندین بار در سمت چپ انتساب
شود، به عنوان مثال ``()x, x := f`` نا معتبر است.

.. code-block:: yul

    let v := 0
    // re-assign v
    v := 2
    let t := add(v, 2)
    function f() -> a, b { }
    // assign multiple values
    v, t := f()


If
--

از دستور if می توان برای اجرای شروط استفاده کرد. بوک “else” قابل تعریف نیست. اگر به
چندین گزینه دیگر نیاز دارید ، به جای آن از “switch” استفاده کنید (پایین را ببینید).

.. code-block:: yul

    if lt(calldatasize(), 4) { revert(0, 0) }

آکولاد برای بدنه لازم است.

Switch
------

می توانید از دستور switch به عنوان نسخه گسترده if استفاده کنید.مقدار یک عبارت را می
گیرد و آن را با چندین مقدار ثابت واقعی مقایسه می کند. در صورت مطابقت بخش مربوطه
گرفته می شود.بر خلاف سایر زبان های برنامه نویسی ، به دلایل امنیتی ، کنترل جریان از یک
کیس به کیس دیگر ادامه نمی یابد. می توان یک کیس پیش فرض ``default`` تعریف کرد که در صوردت
عدم تطابق با دیگر کیس ها آن اجرا شود. 

.. code-block:: yul

    {
        let x := 0
        switch calldataload(4)
        case 0 {
            x := calldataload(0x24)
        }
        default {
            x := calldataload(0x44)
        }
        sstore(0, div(x, 2))
    }

لیست کیس ها نیاز به آکولاد ندارد ولی بدنه کیس ها نیازمند آکولاد باز و بسته هستند.

Loops
-----

یول از حلقه for…loop پشتیبانی می کند که شامل یک قسمت اولبه ، یک شرط ، یک قسمت
بعد از تکرار و یک بدنه است. شرط باید یک عبارت باشد، در حالی که سه مورد دیگر بلوک
هستند. اگر در قسمت مقدماتی تمام متغیر هارا تعریف کند ، دامنه این متغیر ها به سایر قسمت
های حلقه گسترش می یابد.

دستورات ``break``  و ``continue`` را می توان به ترتیب برای خروج از حلقه و یا ادامه حلقه از جایی که باقیمانده استفاده کرد.

مثال زیر جمع مساحت یک منطقه را در حافظه محاسبه می کند.

.. code-block:: yul

    {
        let x := 0
        for { let i := 0 } lt(i, 0x100) { i := add(i, 0x20) } {
            x := add(x, mload(i))
        }
    }

برای حلقه ها می توان به عنوان جایگزین حلقه while نیز استفاده کرد : خیلی ساده قسمت های اولیه و پس از تکرار را خالی بگذارید.

.. code-block:: yul

    {
        let x := 0
        let i := 0
        for { } lt(i, 0x100) { } {     // while(i < 0x100)
            x := add(x, mload(i))
            i := add(i, 0x20)
        }
    }

تعاریف توابع 
---------------------

ول به تعریف توابع اجازه می دهد. اینها نباید با توابع سالیدیتی اشتباه گرفته شوند زیرا آنها
هرگز بخشی از رابط خارجی قرار داد نیستند فضای نامی (namespace) جدا از فضای توابع
سالیدیتی دارند.

برای EVM، توابع یول ورودی های خود را (به کامپیوتر بر می گردانند) از پشته می گیرند و
همچنین نتایج را روی پشته قرار می دهند. توابع تعریف شده توسط کاربر و توابع داخلی دقیقا به
همین روش فرا خوانی می شوند.

توابع را می توان در هر کجا تعریف کرد و بلوکی که در آن اعلام می شوند قابل مشاهده
هستند. در داخل یک تابع ، نمی توانید به متغیر های تعریف شده خارج از تابع دسترسی پیدا کنید.

تعریف پارامتر ها و متغیر های برگشتی در توابع مانند سالیتدی است.
برای برگرداندن متغیر ، آن را به متغیر های برگشتی نسبت دهید.

اگر شما تابعی دارید که چندین متغیر بر می گرداند،
شما باید خروجی را به چندین متغیر نسبت دهدید ``a, b := f(x)``  یا  ``let a, b := f(x)``.

از دستور ``leave`` برا خروج از تابع فعلی می توان استفاده کرد. مانند دستور ``return`` در دیگر
زبان های برنامه نویسی عمل می کند که برگشت مقدار مهم نیست، فقط از تابع خارج می شود
در حالی که متغیر های بازگشتی در آن لحظه هر مقداری که داشته باشند نسبت داده می شوند.

توجه داشته باشید که گویش EVM یک تابع داخلی به نام ``return`` دارد که از اجرای
کل(فراخوانی داخلی سیستم) برنامه خارج می شود و این تابع مختص یول نیست.

مثال تابع توان را پیاده سازی می کند توسط (ضرب درخود عدد – ضرب بر عدد توان) :

.. code-block:: yul

    {
        function power(base, exponent) -> result {
            switch exponent
            case 0 { result := 1 }
            case 1 { result := base }
            default {
                result := power(mul(base, base), div(exponent, 2))
                switch mod(exponent, 2)
                    case 1 { result := mul(base, result) }
            }
        }
    }

مشخصات یول
====================

این فضا به طور رسمی کدینگ یول را توصیف می کند، کد یول معمولا درون شی هایی از نوع
یول قرار می گیرد، که در فصل مخصوص خودش توضیح داده شده است.

.. code-block:: none

    Block = '{' Statement* '}'
    Statement =
        Block |
        FunctionDefinition |
        VariableDeclaration |
        Assignment |
        If |
        Expression |
        Switch |
        ForLoop |
        BreakContinue |
        Leave
    FunctionDefinition =
        'function' Identifier '(' TypedIdentifierList? ')'
        ( '->' TypedIdentifierList )? Block
    VariableDeclaration =
        'let' TypedIdentifierList ( ':=' Expression )?
    Assignment =
        IdentifierList ':=' Expression
    Expression =
        FunctionCall | Identifier | Literal
    If =
        'if' Expression Block
    Switch =
        'switch' Expression ( Case+ Default? | Default )
    Case =
        'case' Literal Block
    Default =
        'default' Block
    ForLoop =
        'for' Block Expression Block Block
    BreakContinue =
        'break' | 'continue'
    Leave = 'leave'
    FunctionCall =
        Identifier '(' ( Expression ( ',' Expression )* )? ')'
    Identifier = [a-zA-Z_$] [a-zA-Z_$0-9.]*
    IdentifierList = Identifier ( ',' Identifier)*
    TypeName = Identifier
    TypedIdentifierList = Identifier ( ':' TypeName )? ( ',' Identifier ( ':' TypeName )? )*
    Literal =
        (NumberLiteral | StringLiteral | TrueLiteral | FalseLiteral) ( ':' TypeName )?
    NumberLiteral = HexNumber | DecimalNumber
    StringLiteral = '"' ([^"\r\n\\] | '\\' .)* '"'
    TrueLiteral = 'true'
    FalseLiteral = 'false'
    HexNumber = '0x' [0-9a-fA-F]+
    DecimalNumber = [0-9]+


محدودیت های دستور زبان
---------------------------

جدا از محدودیت هایی که مستقیما توسط دستور زبان اعمال می شوند ، محدودیت های زیر نیز
اعمال می شوند:

سوئیچ ها باید حداقل یک کیس داشته باشند ( از جمله کیس پیش قرض).
همه مقادر کیس ها باید هم نوع و مقادیر متمایز داشته باشند.
اگر بر تمامی حالت ها کیس نوشته شده باشد نوشت کیس پیش فرض مجاز نیست.
( یعنی یک سویچ از نوع ``bool`` که فقط دارای یک حالت درست و ناردست باشد ، نوشتن کیش پیش فرض مجاز نیست.)

هر عبارت به عنوان صفر یا مقداری بیشتر از صفر ارزیابی می شود. نحوه ارزیابی شناسه
ها(متغیر ها) و اصطلاحات (رشته  و یا اعدادی که خودمان در یک شرط  جهت بررسی وارد می
کنیم) یکسان است و در توابع  نحوه ارزیابی مقادیر بازگشتی به هر تعدادی باشند به همان تعداد
عمل ارزیابی خواهیم داشت

در تعریف و انتساب متغیر ها ، عبارات سمت راست (در صورت وجود)  با مقادیر سمت چپ
باید یکسان باشند. این تنها حالتی است که می توان از چندین مقدار استفاده کرد. متغیر با نام
مشابه نمی تواند بیش از یک بار در سمت چپ انتساب یا تعریف شود.

عباراتی که به صورت بیانیه هستند (یعنی در داخل بلوک هستند) باید با مقادیر صفر سنجیده شوند.

در تمام شرایط دیگر ، عبارات باید دقیقا به یک ارزش سنجیده شوند.

دستورات ``continue`` و ``break`` در داخل بدنه حلقه ها قابل استفاده است و باید همان عملکرد را
که در حلقه دارند نشان دهند( یا هر دو باید در سطح بالایی باشند). از دستورات ``continue`` و
``break`` نمی توان در قسمت های دیگر حلقه استفاده کرد ، حتی در داخل حلقه دوم یک حلقه تو در تو.

قسمت شرط حلقه باید دقیقا یک مقدار سنجیده شود.

دستور ``leave`` فقط داخل توابع قابل استفاده است.

Functions cannot be defined anywhere inside for loop init blocks.

اندازه لیترالز(literals) نمی تواند بزرگتر از نوع آنها باشد. بزرگترین نوع قابل تعریف به اندازه 256 بیت است.

حین انتساب در فراخوانی تابع، مقادیر باید با نوع آنها مطابقت داشته باشند. به هیچ وجه تبدیل
ضمنی مجاز نیست. تبدیل ضمنی بطور کلی فقط زمانی مقدور است که گویش این قابلیت را با
توابع – داخلی مناسب فراهم کند و مقادیر را دریافت و به نوع متفاوت تبدیل کرده وبه خروجی
دهد.

قوانین محدوده ها
----------------

حدود در یول به بلوک ها ختم می شوند ( استثنائات توابع و حلقه های for است که در پایین
شرح داده شده است) و تمامی تعاریف ( ``FunctionDefinition`` ، ``VariableDeclaration``) با شناسه های جدید
در این محدوده معرفی می شوند.

شناسه ها در بلوکی که تعریف شده اند (شامل تمامی نودها-فرعی(sub-nodes)  و بلوکهای-فرعی) در دسترس هستند:

خصوصا ،
نمی توان در سمت راست اول مقدار داد و سپس در سمت چپ نام متغیر را نوشت.
وابع قبل از تعریفشان قابل ارجاع هستند (به شرطی که در محدوده دسترس باشند).

به عنوان استثنا، محدود “ورودی” (init) قسمت حلقه for-loop در تمام قسمت های دیگر حلقه
گسترش یافته است. این بدان معنی است که متغیر های تعریف شده در بخش ورودی(init) (اما
نه بلوکی که داخل بخش ورودی است) درتمامی دیگر بخش های حلقه در دسترس هستند.

شناسه های تعریف شده در قسمت های دیگر حلقه از قوانین محدوده ها تبعیت می کنند.

یعنی یک حلقه for-loop به شکل ``for { I... } C { P... } { B... }`` معادل ``{ I... for {} C { P... } { B... } }``.

پارامتر ها و پارامتر های بازگشتی از توابع در داخل توابع در دسترس هستند و باید نام آنها
متفاوت باشد.

داخل توابع ، این امکان وجود ندارد به متغیری خارج از محدوده تابع نمی توان ارجاع داد.

سایه زدن (shadowing) مجاز نیست ، یعنی شما نمی توانید شناسه ای را که قبلا  در جایی
تعریف کرده اید در جای دیگر شناسه ای به همان نام داشته باشید، حتی اگر در دسترس نباشد.
در داخل توابع، دسترسی به متغیری که خارج از محدوده تابع تعریف شده باشد، امکانپذیر نیست.

مشخصات رسمی 
-----------

ما یول را با فراهم کردن تابع E  اورلود شده (overloaded) در نود های مختلف AST مشخص
می کنیم. مانند توابع داخلی می تواند عوارض جانبی داشته باشد، تابع E دو وضعیت آبجکت (
object state) و نود AST را می گیرد و دو وضعیت آبجکت (object state) جدید و یک متغیر
عددی از دیگر مقادیر را بر می گرداند. این دو وضعیت آبجکت(object state)  عبارتند از
وضعیت آبجکت کل (Global)(که درداخل آنها حافظه EVM ،فضاهای ذخیره سازی و وضعیت
بلاکچین است) و وضعیت آبجکت محلی ( وضعیت متغیر های محلی ، یعنی قسمت(segment)
پشته EVM وجود دارد)

اگر نود AST  یک بیانیه باشد ، تابع E دو وضعیت آبجکت (object state)  برمی گرداند و یک
"حالت" (“mode”) که برای ``break`` ، ``continue`` و ``leave`` عبارت استفاده می شود. اگر این
نود AST یک عبارت باشد، تابع E دو وضعیت آبجکت (object state)  و تعداد زیادی مقادیر بر
می گرداند که به عنوان عبارت ارزیابی می شوند


ماهیت دقیق وضعیت کل(global) نامشخص و غیر قابل توصیف در سطح بالای برنامه نویسی
است. وضعیت محلی ``L`` با شناسه های ``i`` به مقادیر ``v`` به عنوان ``L[i] = v`` نشان داده شده است.

برای شناسه ``v`` اجازه دهید ``$v`` نام شناسه باشد.

ما از یک علامت غیر ساختاری برا نودهای AST استفاده خواهیم کرد.

.. code-block:: none

    E(G, L, <{St1, ..., Stn}>: Block) =
        let G1, L1, mode = E(G, L, St1, ..., Stn)
        let L2 be a restriction of L1 to the identifiers of L
        G1, L2, mode
    E(G, L, St1, ..., Stn: Statement) =
        if n is zero:
            G, L, regular
        else:
            let G1, L1, mode = E(G, L, St1)
            if mode is regular then
                E(G1, L1, St2, ..., Stn)
            otherwise
                G1, L1, mode
    E(G, L, FunctionDefinition) =
        G, L, regular
    E(G, L, <let var_1, ..., var_n := rhs>: VariableDeclaration) =
        E(G, L, <var_1, ..., var_n := rhs>: Assignment)
    E(G, L, <let var_1, ..., var_n>: VariableDeclaration) =
        let L1 be a copy of L where L1[$var_i] = 0 for i = 1, ..., n
        G, L1, regular
    E(G, L, <var_1, ..., var_n := rhs>: Assignment) =
        let G1, L1, v1, ..., vn = E(G, L, rhs)
        let L2 be a copy of L1 where L2[$var_i] = vi for i = 1, ..., n
        G, L2, regular
    E(G, L, <for { i1, ..., in } condition post body>: ForLoop) =
        if n >= 1:
            let G1, L, mode = E(G, L, i1, ..., in)
            // mode has to be regular or leave due to the syntactic restrictions
            if mode is leave then
                G1, L1 restricted to variables of L, leave
            otherwise
                let G2, L2, mode = E(G1, L1, for {} condition post body)
                G2, L2 restricted to variables of L, mode
        else:
            let G1, L1, v = E(G, L, condition)
            if v is false:
                G1, L1, regular
            else:
                let G2, L2, mode = E(G1, L, body)
                if mode is break:
                    G2, L2, regular
                otherwise if mode is leave:
                    G2, L2, leave
                else:
                    G3, L3, mode = E(G2, L2, post)
                    if mode is leave:
                        G2, L3, leave
                    otherwise
                        E(G3, L3, for {} condition post body)
    E(G, L, break: BreakContinue) =
        G, L, break
    E(G, L, continue: BreakContinue) =
        G, L, continue
    E(G, L, leave: Leave) =
        G, L, leave
    E(G, L, <if condition body>: If) =
        let G0, L0, v = E(G, L, condition)
        if v is true:
            E(G0, L0, body)
        else:
            G0, L0, regular
    E(G, L, <switch condition case l1:t1 st1 ... case ln:tn stn>: Switch) =
        E(G, L, switch condition case l1:t1 st1 ... case ln:tn stn default {})
    E(G, L, <switch condition case l1:t1 st1 ... case ln:tn stn default st'>: Switch) =
        let G0, L0, v = E(G, L, condition)
        // i = 1 .. n
        // Evaluate literals, context doesn't matter
        let _, _, v1 = E(G0, L0, l1)
        ...
        let _, _, vn = E(G0, L0, ln)
        if there exists smallest i such that vi = v:
            E(G0, L0, sti)
        else:
            E(G0, L0, st')

    E(G, L, <name>: Identifier) =
        G, L, L[$name]
    E(G, L, <fname(arg1, ..., argn)>: FunctionCall) =
        G1, L1, vn = E(G, L, argn)
        ...
        G(n-1), L(n-1), v2 = E(G(n-2), L(n-2), arg2)
        Gn, Ln, v1 = E(G(n-1), L(n-1), arg1)
        Let <function fname (param1, ..., paramn) -> ret1, ..., retm block>
        be the function of name $fname visible at the point of the call.
        Let L' be a new local state such that
        L'[$parami] = vi and L'[$reti] = 0 for all i.
        Let G'', L'', mode = E(Gn, L', block)
        G'', Ln, L''[$ret1], ..., L''[$retm]
    E(G, L, l: StringLiteral) = G, L, utf8EncodeLeftAligned(l),
        where utf8EncodeLeftAligned performs a UTF-8 encoding of l
        and aligns it left into 32 bytes
    E(G, L, n: HexNumber) = G, L, hex(n)
        where hex is the hexadecimal decoding function
    E(G, L, n: DecimalNumber) = G, L, dec(n),
        where dec is the decimal decoding function

.. _opcodes:

گویش EVM
--------

گویش پیش فرض یول در حال حاضر گویش EVM در نشخه فعلی انتخاب شده EVM است. با
نسخه ای از EVM ، تنها حالت موجود در این گویش ``u256`` است ، حالت خام 256 بیت ماشین
مجازی اتریوم. از آنجایی که حالت پیش فرض گویش است می توان از آن صرف نظر کرد.

جدول زیر (بسته به نوع نسخه EVM) تمام توابع ساخته شده را لیست می کند و شرح مختصری
از عملکرد/کد گذاری را ارئه می دهد. این سند نمی خواهد شرح کاملی از ماشین مجازی اتریوم
باشد. اگر علاقه مندبه معتای دقیق هستید، لطفا به سند دیگری مراجعه کنید.

کد ها با علامت – نشانه گذاری شده اند نتیجه ای بر نمی گردانند و تمامی آنها یک مقدار را بر
می گرداند. کد هایی که با ``F``، ``H``، ``B`` و ``C`` یا ``I`` و ``L``  نشانه گذاری شده اند به ترتیب از زمان
Frontainter،  Homestead ، Byzantium  و Constantinople یا Istanbul و London وجود دارند.

در ادامه ``(mem[a...b`` نشانگر بایت های حافظه است که از موقعیت ``a`` شروع و تا ``b`` منتهی
میشوند در حالی خود خانه b شامل حافظه نیست و ``storage[p]`` بیانگر محتوای داخل فضای
ذخیره سازی اسلات ``p`` است.

از آنجایی که یول متغیر های محلی و کنترل جریان را مدیریت می کند ، کد هایی که با این
ویژگی ها تداخل می کنند وجود ندارند. این شامل دستور های ``dup`` و ``swap`` و همچنین دستور
های ``jump`` ، برچسب ها و دستور ``push`` می باشد.

+-------------------------+-----+---+-----------------------------------------------------------------+
| Instruction             |     |   | Explanation                                                     |
+=========================+=====+===+=================================================================+
| stop()                  + `-` | F | stop execution, identical to return(0, 0)                       |
+-------------------------+-----+---+-----------------------------------------------------------------+
| add(x, y)               |     | F | x + y                                                           |
+-------------------------+-----+---+-----------------------------------------------------------------+
| sub(x, y)               |     | F | x - y                                                           |
+-------------------------+-----+---+-----------------------------------------------------------------+
| mul(x, y)               |     | F | x * y                                                           |
+-------------------------+-----+---+-----------------------------------------------------------------+
| div(x, y)               |     | F | x / y or 0 if y == 0                                            |
+-------------------------+-----+---+-----------------------------------------------------------------+
| sdiv(x, y)              |     | F | x / y, for signed numbers in two's complement, 0 if y == 0      |
+-------------------------+-----+---+-----------------------------------------------------------------+
| mod(x, y)               |     | F | x % y, 0 if y == 0                                              |
+-------------------------+-----+---+-----------------------------------------------------------------+
| smod(x, y)              |     | F | x % y, for signed numbers in two's complement, 0 if y == 0      |
+-------------------------+-----+---+-----------------------------------------------------------------+
| exp(x, y)               |     | F | x to the power of y                                             |
+-------------------------+-----+---+-----------------------------------------------------------------+
| not(x)                  |     | F | bitwise "not" of x (every bit of x is negated)                  |
+-------------------------+-----+---+-----------------------------------------------------------------+
| lt(x, y)                |     | F | 1 if x < y, 0 otherwise                                         |
+-------------------------+-----+---+-----------------------------------------------------------------+
| gt(x, y)                |     | F | 1 if x > y, 0 otherwise                                         |
+-------------------------+-----+---+-----------------------------------------------------------------+
| slt(x, y)               |     | F | 1 if x < y, 0 otherwise, for signed numbers in two's complement |
+-------------------------+-----+---+-----------------------------------------------------------------+
| sgt(x, y)               |     | F | 1 if x > y, 0 otherwise, for signed numbers in two's complement |
+-------------------------+-----+---+-----------------------------------------------------------------+
| eq(x, y)                |     | F | 1 if x == y, 0 otherwise                                        |
+-------------------------+-----+---+-----------------------------------------------------------------+
| iszero(x)               |     | F | 1 if x == 0, 0 otherwise                                        |
+-------------------------+-----+---+-----------------------------------------------------------------+
| and(x, y)               |     | F | bitwise "and" of x and y                                        |
+-------------------------+-----+---+-----------------------------------------------------------------+
| or(x, y)                |     | F | bitwise "or" of x and y                                         |
+-------------------------+-----+---+-----------------------------------------------------------------+
| xor(x, y)               |     | F | bitwise "xor" of x and y                                        |
+-------------------------+-----+---+-----------------------------------------------------------------+
| byte(n, x)              |     | F | nth byte of x, where the most significant byte is the 0th byte  |
+-------------------------+-----+---+-----------------------------------------------------------------+
| shl(x, y)               |     | C | logical shift left y by x bits                                  |
+-------------------------+-----+---+-----------------------------------------------------------------+
| shr(x, y)               |     | C | logical shift right y by x bits                                 |
+-------------------------+-----+---+-----------------------------------------------------------------+
| sar(x, y)               |     | C | signed arithmetic shift right y by x bits                       |
+-------------------------+-----+---+-----------------------------------------------------------------+
| addmod(x, y, m)         |     | F | (x + y) % m with arbitrary precision arithmetic, 0 if m == 0    |
+-------------------------+-----+---+-----------------------------------------------------------------+
| mulmod(x, y, m)         |     | F | (x * y) % m with arbitrary precision arithmetic, 0 if m == 0    |
+-------------------------+-----+---+-----------------------------------------------------------------+
| signextend(i, x)        |     | F | sign extend from (i*8+7)th bit counting from least significant  |
+-------------------------+-----+---+-----------------------------------------------------------------+
| keccak256(p, n)         |     | F | keccak(mem[p...(p+n)))                                          |
+-------------------------+-----+---+-----------------------------------------------------------------+
| pc()                    |     | F | current position in code                                        |
+-------------------------+-----+---+-----------------------------------------------------------------+
| pop(x)                  | `-` | F | discard value x                                                 |
+-------------------------+-----+---+-----------------------------------------------------------------+
| mload(p)                |     | F | mem[p...(p+32))                                                 |
+-------------------------+-----+---+-----------------------------------------------------------------+
| mstore(p, v)            | `-` | F | mem[p...(p+32)) := v                                            |
+-------------------------+-----+---+-----------------------------------------------------------------+
| mstore8(p, v)           | `-` | F | mem[p] := v & 0xff (only modifies a single byte)                |
+-------------------------+-----+---+-----------------------------------------------------------------+
| sload(p)                |     | F | storage[p]                                                      |
+-------------------------+-----+---+-----------------------------------------------------------------+
| sstore(p, v)            | `-` | F | storage[p] := v                                                 |
+-------------------------+-----+---+-----------------------------------------------------------------+
| msize()                 |     | F | size of memory, i.e. largest accessed memory index              |
+-------------------------+-----+---+-----------------------------------------------------------------+
| gas()                   |     | F | gas still available to execution                                |
+-------------------------+-----+---+-----------------------------------------------------------------+
| address()               |     | F | address of the current contract / execution context             |
+-------------------------+-----+---+-----------------------------------------------------------------+
| balance(a)              |     | F | wei balance at address a                                        |
+-------------------------+-----+---+-----------------------------------------------------------------+
| selfbalance()           |     | I | equivalent to balance(address()), but cheaper                   |
+-------------------------+-----+---+-----------------------------------------------------------------+
| caller()                |     | F | call sender (excluding ``delegatecall``)                        |
+-------------------------+-----+---+-----------------------------------------------------------------+
| callvalue()             |     | F | wei sent together with the current call                         |
+-------------------------+-----+---+-----------------------------------------------------------------+
| calldataload(p)         |     | F | call data starting from position p (32 bytes)                   |
+-------------------------+-----+---+-----------------------------------------------------------------+
| calldatasize()          |     | F | size of call data in bytes                                      |
+-------------------------+-----+---+-----------------------------------------------------------------+
| calldatacopy(t, f, s)   | `-` | F | copy s bytes from calldata at position f to mem at position t   |
+-------------------------+-----+---+-----------------------------------------------------------------+
| codesize()              |     | F | size of the code of the current contract / execution context    |
+-------------------------+-----+---+-----------------------------------------------------------------+
| codecopy(t, f, s)       | `-` | F | copy s bytes from code at position f to mem at position t       |
+-------------------------+-----+---+-----------------------------------------------------------------+
| extcodesize(a)          |     | F | size of the code at address a                                   |
+-------------------------+-----+---+-----------------------------------------------------------------+
| extcodecopy(a, t, f, s) | `-` | F | like codecopy(t, f, s) but take code at address a               |
+-------------------------+-----+---+-----------------------------------------------------------------+
| returndatasize()        |     | B | size of the last returndata                                     |
+-------------------------+-----+---+-----------------------------------------------------------------+
| returndatacopy(t, f, s) | `-` | B | copy s bytes from returndata at position f to mem at position t |
+-------------------------+-----+---+-----------------------------------------------------------------+
| extcodehash(a)          |     | C | code hash of address a                                          |
+-------------------------+-----+---+-----------------------------------------------------------------+
| create(v, p, n)         |     | F | create new contract with code mem[p...(p+n)) and send v wei     |
|                         |     |   | and return the new address; returns 0 on error                  |
+-------------------------+-----+---+-----------------------------------------------------------------+
| create2(v, p, n, s)     |     | C | create new contract with code mem[p...(p+n)) at address         |
|                         |     |   | keccak256(0xff . this . s . keccak256(mem[p...(p+n)))           |
|                         |     |   | and send v wei and return the new address, where ``0xff`` is a  |
|                         |     |   | 1 byte value, ``this`` is the current contract's address        |
|                         |     |   | as a 20 byte value and ``s`` is a big-endian 256-bit value;     |
|                         |     |   | returns 0 on error                                              |
+-------------------------+-----+---+-----------------------------------------------------------------+
| call(g, a, v, in,       |     | F | call contract at address a with input mem[in...(in+insize))     |
| insize, out, outsize)   |     |   | providing g gas and v wei and output area                       |
|                         |     |   | mem[out...(out+outsize)) returning 0 on error (eg. out of gas)  |
|                         |     |   | and 1 on success                                                |
|                         |     |   | :ref:`See more <yul-call-return-area>`                          |
+-------------------------+-----+---+-----------------------------------------------------------------+
| callcode(g, a, v, in,   |     | F | identical to ``call`` but only use the code from a and stay     |
| insize, out, outsize)   |     |   | in the context of the current contract otherwise                |
|                         |     |   | :ref:`See more <yul-call-return-area>`                          |
+-------------------------+-----+---+-----------------------------------------------------------------+
| delegatecall(g, a, in,  |     | H | identical to ``callcode`` but also keep ``caller``              |
| insize, out, outsize)   |     |   | and ``callvalue``                                               |
|                         |     |   | :ref:`See more <yul-call-return-area>`                          |
+-------------------------+-----+---+-----------------------------------------------------------------+
| staticcall(g, a, in,    |     | B | identical to ``call(g, a, 0, in, insize, out, outsize)`` but do |
| insize, out, outsize)   |     |   | not allow state modifications                                   |
|                         |     |   | :ref:`See more <yul-call-return-area>`                          |
+-------------------------+-----+---+-----------------------------------------------------------------+
| return(p, s)            | `-` | F | end execution, return data mem[p...(p+s))                       |
+-------------------------+-----+---+-----------------------------------------------------------------+
| revert(p, s)            | `-` | B | end execution, revert state changes, return data mem[p...(p+s)) |
+-------------------------+-----+---+-----------------------------------------------------------------+
| selfdestruct(a)         | `-` | F | end execution, destroy current contract and send funds to a     |
+-------------------------+-----+---+-----------------------------------------------------------------+
| invalid()               | `-` | F | end execution with invalid instruction                          |
+-------------------------+-----+---+-----------------------------------------------------------------+
| log0(p, s)              | `-` | F | log without topics and data mem[p...(p+s))                      |
+-------------------------+-----+---+-----------------------------------------------------------------+
| log1(p, s, t1)          | `-` | F | log with topic t1 and data mem[p...(p+s))                       |
+-------------------------+-----+---+-----------------------------------------------------------------+
| log2(p, s, t1, t2)      | `-` | F | log with topics t1, t2 and data mem[p...(p+s))                  |
+-------------------------+-----+---+-----------------------------------------------------------------+
| log3(p, s, t1, t2, t3)  | `-` | F | log with topics t1, t2, t3 and data mem[p...(p+s))              |
+-------------------------+-----+---+-----------------------------------------------------------------+
| log4(p, s, t1, t2, t3,  | `-` | F | log with topics t1, t2, t3, t4 and data mem[p...(p+s))          |
| t4)                     |     |   |                                                                 |
+-------------------------+-----+---+-----------------------------------------------------------------+
| chainid()               |     | I | ID of the executing chain (EIP-1344)                            |
+-------------------------+-----+---+-----------------------------------------------------------------+
| basefee()               |     | L | current block's base fee (EIP-3198 and EIP-1559)                |
+-------------------------+-----+---+-----------------------------------------------------------------+
| origin()                |     | F | transaction sender                                              |
+-------------------------+-----+---+-----------------------------------------------------------------+
| gasprice()              |     | F | gas price of the transaction                                    |
+-------------------------+-----+---+-----------------------------------------------------------------+
| blockhash(b)            |     | F | hash of block nr b - only for last 256 blocks excluding current |
+-------------------------+-----+---+-----------------------------------------------------------------+
| coinbase()              |     | F | current mining beneficiary                                      |
+-------------------------+-----+---+-----------------------------------------------------------------+
| timestamp()             |     | F | timestamp of the current block in seconds since the epoch       |
+-------------------------+-----+---+-----------------------------------------------------------------+
| number()                |     | F | current block number                                            |
+-------------------------+-----+---+-----------------------------------------------------------------+
| difficulty()            |     | F | difficulty of the current block                                 |
+-------------------------+-----+---+-----------------------------------------------------------------+
| gaslimit()              |     | F | block gas limit of the current block                            |
+-------------------------+-----+---+-----------------------------------------------------------------+

.. _yul-call-return-area:

.. note::
  دستورالعمل های ``*call`` استفاده می شوند برای تعریف منطقه پارامتر های خروجی ``out`` و
  اندازه خروجی ``outsize`` در حافظه که داده یا داده خطادار بازگشتی در آن قرار می گیرند. این منطقه
  وابسته به تعداد بایت برگشتی از طرف قرارداد فراخوانی شده است. اگر آن داده بیشتری
  برگرداند، فقط اولین اندازه بایت های خروجی ``outsize`` نوشته می شوند، شما می تواننید به
  بقیه داده ها توسط کد ``returndatacopy`` دسترسی داشته باشید. اگر آن داده کمتری برگرداند،
  در کل به بقیه بایت ها رزرو دست زده نمی شود. شما می توانید از کد ``returndatacopy`` جهت
  بررسی کدام بخش از حافظه شامل داده های برگشتی است، استفاده کنید. بایت های باقی
  مانده مقداری را برمی گردانند که توسط فراخوانی های قبلی آنها مقدار دهی شده بوده اند.

بعضی از گویش های داخلی، توابع اضافی دارند:

datasize, dataoffset, datacopy
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

توابع ``datasize(x)`` , ``dataoffset(x)``  و  ``datacopy(t, f, l)`` برای دسترسی به دیگر بخش های شی ای از یول استفاده می شود.

``datasize``  و ``dataoffset`` تنها می توانند لیترالز(literals) رشته ای(نام شی های دیگر) را به
عنوان وروردی قبول کنند، سایز و محدوده داده را به ترتیب بر می گردانند. برای EVM تابع
``datacopy`` همان ``codecopy``  می باشد.

setimmutable, loadimmutable
^^^^^^^^^^^^^^^^^^^^^^^^^^^

The functions ``setimmutable(offset, "name", value)`` and ``loadimmutable("name")`` are
used for the immutable mechanism in Solidity and do not nicely map to pure Yul.
The call to ``setimmutable(offset, "name", value)`` assumes that the runtime code of the contract
containing the given named immutable was copied to memory at offset ``offset`` and will write ``value`` to all
positions in memory (relative to ``offset``) that contain the placeholder that was generated for calls
to ``loadimmutable("name")`` in the runtime code.


linkersymbol
^^^^^^^^^^^^

تابع  ``linkersymbol("fq_library_name")`` یک آدرس لیترال (literal) است که توسط لینکر(
linker) جایگزین می شود. اولین و تنها ورودی باید یک رشته لیترال (literal) باشد و با گزینه ``libraries--``
که نشان دهنده نام کامل کتابخانه منتخب است استفاده می شود.

برای مثال این کد

.. code-block:: yul

    let a := linkersymbol("file.sol:Math")

برابر است با

.. code-block:: yul

    let a := 0x1234567890123456789012345678901234567890

وقتی لینکر(linker) با گزینه ``--libraries "file.sol:Math=0x1234567890123456789012345678901234567890`` باشد.

برای جزئیات بیشتر سالیدیتی لینکر از :ref:`خط فرمان کامپایلر <commandline-compiler>` دیدن کنید.

محافظ حافظه
^^^^^^^^^^^

این تابع در گویش EVM به همراه شی ها (objects) موجود است. فراخوان  ``let ptr := memoryguard(size)`` ( که ``size`` لیترالی  از نوع عددی است
( قول می دهد که حافظه فقط در بازه ``[0, size)`` ) و یا از محدوده مشخص شده توسط ``ptr`` شروع شود.

از انجایی که وجود یک محافظ حافظه ``memoryguard`` نشان دهنده ی این است که تمام
دسترسی های حافظه به این محدودیت پایبند هستند، به بهینه ساز اجازه می دهد که بتواند
مراحل اضافی بهینه سازی را انجام دهد، برای مثال رد کردن محدوده پشته که سعی دارد متغیر
های داخل بشته را انتقال دهد که در این حالت به حافظه غیر قابل دسترس خواهد یود.

بهینه ساز یول وعده می دهد برای اهداف خود تنها از بازه ``[size, ptr)`` حافظه استفاده کند.
اگر بهینه ساز نیاز به رزرو حافظه نداشته باشد ، محدوده حافظه را به همین مقدار ``ptr == size`` نگه می دارد.

``memoryguard`` را می توان چندین بار فراخوانی کرد، اما لازم است همان لیترال(literal) به
عنوان ورودی به همراه یک شی فرعی(subobject) یول داشته باشیم.  اگر حداقل یک
فراخوانی ``memoryguard`` در یک شی فرعی (subobject) پیدا شود، مراحل اضافی بهینه
ساز در آن اجرا می شود


.. _yul-verbatim:

verbatim
^^^^^^^^

The set of ``verbatim...`` builtin functions lets you create bytecode for opcodes
that are not known to the Yul compiler. It also allows you to create
bytecode sequences that will not be modified by the optimizer.

The functions are ``verbatim_<n>i_<m>o("<data>", ...)``, where

- ``n`` is a decimal between 0 and 99 that specifies the number of input stack slots / variables
- ``m`` is a decimal between 0 and 99 that specifies the number of output stack slots / variables
- ``data`` is a string literal that contains the sequence of bytes

If you for example want to define a function that multiplies the input
by two, without the optimizer touching the constant two, you can use

.. code-block:: yul

    let x := calldataload(0)
    let double := verbatim_1i_1o(hex"600202", x)

This code will result in a ``dup1`` opcode to retrieve ``x``
(the optimizer might directly re-use result of the
``calldataload`` opcode, though)
directly followed by ``600202``. The code is assumed to
consume the copied value of ``x`` and produce the result
on the top of the stack. The compiler then generates code
to allocate a stack slot for ``double`` and store the result there.

As with all opcodes, the arguments are arranged on the stack
with the leftmost argument on the top, while the return values
are assumed to be laid out such that the rightmost variable is
at the top of the stack.

Since ``verbatim`` can be used to generate arbitrary opcodes
or even opcodes unknown to the Solidity compiler, care has to be taken
when using ``verbatim`` together with the optimizer. Even when the
optimizer is switched off, the code generator has to determine
the stack layout, which means that e.g. using ``verbatim`` to modify
the stack height can lead to undefined behaviour.

The following is a non-exhaustive list of restrictions on
verbatim bytecode that are not checked by
the compiler. Violations of these restrictions can result in
undefined behaviour.

- Control-flow should not jump into or out of verbatim blocks,
  but it can jump within the same verbatim block.
- Stack contents apart from the input and output parameters
  should not be accessed.
- The stack height difference should be exactly ``m - n``
  (output slots minus input slots).
- Verbatim bytecode cannot make any assumptions about the
  surrounding bytecode. All required parameters have to be
  passed in as stack variables.

The optimizer does not analyze verbatim bytecode and always
assumes that it modifies all aspects of state and thus can only
do very few optimizations across ``verbatim`` function calls.

The optimizer treats verbatim bytecode as an opaque block of code.
It will not split it but might move, duplicate
or combine it with identical verbatim bytecode blocks.
If a verbatim bytecode block is unreachable by the control-flow,
it can be removed.


.. warning::

    During discussions about whether or not EVM improvements
    might break existing smart contracts, features inside ``verbatim``
    cannot receive the same consideration as those used by the Solidity
    compiler itself.

.. note::

    To avoid confusion, all identifiers starting with the string ``verbatim`` are reserved
    and cannot be used for user-defined identifiers.

.. _yul-object:

خصوصیات شئ یول
===========================

شی های یول برای گروهبندی نامگذاری کد و بخش داده استفاده می شوند. از توابع
``datacopy`` , ``datasize``  و ``dataoffset`` می توان برای دسترسی به این بخشها داخل کد استفاده کرد.
رشته ها در مبنای شانزده می توانند جهت مشخص کردن کدگذاری در مبنای شانزده و رشت
های معمولی جهت مشخص کردن کدگذاری معمولی استفاده شوند، برای کد ``datacopy`` ، به
نمایش اسمبل شده باینری آن دسترسی خواهیم داشت.

.. code-block:: none

    Object = 'object' StringLiteral '{' Code ( Object | Data )* '}'
    Code = 'code' Block
    Data = 'data' StringLiteral ( HexLiteral | StringLiteral )
    HexLiteral = 'hex' ('"' ([0-9a-fA-F]{2})* '"' | '\'' ([0-9a-fA-F]{2})* '\'')
    StringLiteral = '"' ([^"\r\n\\] | '\\' .)* '"'

بالا، ``بلوک`` به ``بلوکی`` که در بخش یول قبلا توضیح داده شده است در فصل قبل اشاره می کند. 

.. note::

    Data objects or sub-objects whose names contain a ``.`` can be defined
    but it is not possible to access them through ``datasize``,
    ``dataoffset`` or ``datacopy`` because ``.`` is used as a separator
    to access objects inside another object.

.. note::

    The data object called ``".metadata"`` has a special meaning:
    It cannot be accessed from code and is always appended to the very end of the
    bytecode, regardless of its position in the object.

    Other data objects with special significance might be added in the
    future, but their names will always start with a ``.``.


مثالی از شئ یول در زیر نمایش داده می شود:

.. code-block:: yul

    // A contract consists of a single object with sub-objects representing
    // the code to be deployed or other contracts it can create.
    // The single "code" node is the executable code of the object.
    // Every (other) named object or data section is serialized and
    // made accessible to the special built-in functions datacopy / dataoffset / datasize
    // The current object, sub-objects and data items inside the current object
    // are in scope.
    object "Contract1" {
        // This is the constructor code of the contract.
        code {
            function allocate(size) -> ptr {
                ptr := mload(0x40)
                if iszero(ptr) { ptr := 0x60 }
                mstore(0x40, add(ptr, size))
            }

            // first create "Contract2"
            let size := datasize("Contract2")
            let offset := allocate(size)
            // This will turn into codecopy for EVM
            datacopy(offset, dataoffset("Contract2"), size)
            // constructor parameter is a single number 0x1234
            mstore(add(offset, size), 0x1234)
            pop(create(offset, add(size, 32), 0))

            // now return the runtime object (the currently
            // executing code is the constructor code)
            size := datasize("runtime")
            offset := allocate(size)
            // This will turn into a memory->memory copy for Ewasm and
            // a codecopy for EVM
            datacopy(offset, dataoffset("runtime"), size)
            return(offset, size)
        }

        data "Table2" hex"4123"

        object "runtime" {
            code {
                function allocate(size) -> ptr {
                    ptr := mload(0x40)
                    if iszero(ptr) { ptr := 0x60 }
                    mstore(0x40, add(ptr, size))
                }

                // runtime code

                mstore(0, "Hello, World!")
                return(0, 0x20)
            }
        }

        // Embedded object. Use case is that the outside is a factory contract,
        // and Contract2 is the code to be created by the factory
        object "Contract2" {
            code {
                // code here ...
            }

            object "runtime" {
                code {
                    // code here ...
                }
            }

            data "Table1" hex"4123"
        }
    }

بهینه ساز یول
=============

بهینه ساز یول با کد یول کار می کند و برای ورودی ، خروجی و خالت های میانی از همان زبان
استفاده می کند. این اجازه می دهد که بهینه ساز عیب یابی(debugging) و راستی آزمایی
آسان انجام دهد. 

Please refer to the general :ref:`optimizer documentation <optimizer>`
for more details about the different optimization stages and how to use the optimizer.

اگر می خواهید از سالیدیتی به صورت مستقل در حالت یول استفاده کنید، باید بهینه ساز را به استفاده از ``optimize--`` فعال کنید:
and optionally specify the :ref:`expected number of contract executions <optimizer-parameter-runs>` with
``--optimize-runs``:

.. code-block:: sh

    solc --strict-assembly --optimize --optimize-runs 200

در حالت سالیدیتی، بهینه ساز یول به همراه بهینه ساز معمولی فعال هستند.

ترتیب قدم بهینه سازی
--------------------

به طور پیش فرض بهینه ساز یول برای بهینه سازی ، از ترتیب از قبل تعیین شده بر روی از کد
های اسمبلی  تولید شده استفاده می کند. شما می توانید بجای این ترتیب از ترتیب خود با گزینه
از ``yul-optimizations--`` استفاده کنید:

.. code-block:: sh

    solc --optimize --ir-optimized --yul-optimizations 'dhfoD[xarrscLMcCTU]uljmul'

ترتیب مراحل مهم است و بر کیفیت خروجی تاثیر می گذارد. علاوه بر این، استفاده از یک
مرحله ممکن است فرصت های جدید بهینه سازی را برای دیگران که قبلا استفاده کرده اند
ایجاد کند، بنابراین تکرار مراحل اغلب سومند است. با قرار دادن بخشی از ترتیب در کروشه
(``[]``) به بهینه ساز می گویید که آن قسمت را به طور مکرر آنقدر بهینه سازی کند تا جایی که
دیگر نتواند به نتیجه کد اسمبلی بهبود بخشد. شما می توانید از کروشه ها چندین بار در یک
ترتیب استفاده کنید اما نمی توان از آنها بصورت تو در تو استفاده کرد. 

قدم های بیهیه سازی ذیل موجود می باشند:

============ ===============================
Abbreviation Full name
============ ===============================
``f``        ``BlockFlattener``
``l``        ``CircularReferencesPruner``
``c``        ``CommonSubexpressionEliminator``
``C``        ``ConditionalSimplifier``
``U``        ``ConditionalUnsimplifier``
``n``        ``ControlFlowSimplifier``
``D``        ``DeadCodeEliminator``
``v``        ``EquivalentFunctionCombiner``
``e``        ``ExpressionInliner``
``j``        ``ExpressionJoiner``
``s``        ``ExpressionSimplifier``
``x``        ``ExpressionSplitter``
``I``        ``ForLoopConditionIntoBody``
``O``        ``ForLoopConditionOutOfBody``
``o``        ``ForLoopInitRewriter``
``i``        ``FullInliner``
``g``        ``FunctionGrouper``
``h``        ``FunctionHoister``
``F``        ``FunctionSpecializer``
``T``        ``LiteralRematerialiser``
``L``        ``LoadResolver``
``M``        ``LoopInvariantCodeMotion``
``r``        ``RedundantAssignEliminator``
``R``        ``ReasoningBasedSimplifier`` - highly experimental
``m``        ``Rematerialiser``
``V``        ``SSAReverser``
``a``        ``SSATransform``
``t``        ``StructuralSimplifier``
``u``        ``UnusedPruner``
``p``        ``UnusedFunctionParameterPruner``
``d``        ``VarDeclInitializer``
============ ===============================

بعضی مراحل به ویژگی های تضمینی توسط ``BlockFlattener`` , ``FunctionGrouper`` , ``ForLoopInitRewriter`` وابسته هستند.
به همین دلیل بهینه ساز یول همیشه آنها را قبل از اجرای مراحل بهینه سازی ارائه شده توسط کاربر ، خودش اعمال می کند.

ReasoningBasedSimplifier یک مرحله بهینه سازی است که در حال حاضر به صورت بیش
فرض در سلسله مراحل بهینه سازی فعال نیست. آن جهت ساده سازی عبارات محاسبانی و
شرط های که از نوع بولئن(Boolean condition) هستند ، از یک تجزیه کننده SMT استفاده
می کند. هنوز آزمایش یا راستی آزمایی دریافت نکرده است و می تواند نتایج غیر قابل تولید
مجدد ایجاد کند لطفا با احتیاط استفاده کنید!

.. _erc20yul:

مثال کامل ERC20
===============

.. code-block:: yul

    object "Token" {
        code {
            // Store the creator in slot zero.
            sstore(0, caller())

            // Deploy the contract
            datacopy(0, dataoffset("runtime"), datasize("runtime"))
            return(0, datasize("runtime"))
        }
        object "runtime" {
            code {
                // Protection against sending Ether
                require(iszero(callvalue()))

                // Dispatcher
                switch selector()
                case 0x70a08231 /* "balanceOf(address)" */ {
                    returnUint(balanceOf(decodeAsAddress(0)))
                }
                case 0x18160ddd /* "totalSupply()" */ {
                    returnUint(totalSupply())
                }
                case 0xa9059cbb /* "transfer(address,uint256)" */ {
                    transfer(decodeAsAddress(0), decodeAsUint(1))
                    returnTrue()
                }
                case 0x23b872dd /* "transferFrom(address,address,uint256)" */ {
                    transferFrom(decodeAsAddress(0), decodeAsAddress(1), decodeAsUint(2))
                    returnTrue()
                }
                case 0x095ea7b3 /* "approve(address,uint256)" */ {
                    approve(decodeAsAddress(0), decodeAsUint(1))
                    returnTrue()
                }
                case 0xdd62ed3e /* "allowance(address,address)" */ {
                    returnUint(allowance(decodeAsAddress(0), decodeAsAddress(1)))
                }
                case 0x40c10f19 /* "mint(address,uint256)" */ {
                    mint(decodeAsAddress(0), decodeAsUint(1))
                    returnTrue()
                }
                default {
                    revert(0, 0)
                }

                function mint(account, amount) {
                    require(calledByOwner())

                    mintTokens(amount)
                    addToBalance(account, amount)
                    emitTransfer(0, account, amount)
                }
                function transfer(to, amount) {
                    executeTransfer(caller(), to, amount)
                }
                function approve(spender, amount) {
                    revertIfZeroAddress(spender)
                    setAllowance(caller(), spender, amount)
                    emitApproval(caller(), spender, amount)
                }
                function transferFrom(from, to, amount) {
                    decreaseAllowanceBy(from, caller(), amount)
                    executeTransfer(from, to, amount)
                }

                function executeTransfer(from, to, amount) {
                    revertIfZeroAddress(to)
                    deductFromBalance(from, amount)
                    addToBalance(to, amount)
                    emitTransfer(from, to, amount)
                }


                /* ---------- calldata decoding functions ----------- */
                function selector() -> s {
                    s := div(calldataload(0), 0x100000000000000000000000000000000000000000000000000000000)
                }

                function decodeAsAddress(offset) -> v {
                    v := decodeAsUint(offset)
                    if iszero(iszero(and(v, not(0xffffffffffffffffffffffffffffffffffffffff)))) {
                        revert(0, 0)
                    }
                }
                function decodeAsUint(offset) -> v {
                    let pos := add(4, mul(offset, 0x20))
                    if lt(calldatasize(), add(pos, 0x20)) {
                        revert(0, 0)
                    }
                    v := calldataload(pos)
                }
                /* ---------- calldata encoding functions ---------- */
                function returnUint(v) {
                    mstore(0, v)
                    return(0, 0x20)
                }
                function returnTrue() {
                    returnUint(1)
                }

                /* -------- events ---------- */
                function emitTransfer(from, to, amount) {
                    let signatureHash := 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
                    emitEvent(signatureHash, from, to, amount)
                }
                function emitApproval(from, spender, amount) {
                    let signatureHash := 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
                    emitEvent(signatureHash, from, spender, amount)
                }
                function emitEvent(signatureHash, indexed1, indexed2, nonIndexed) {
                    mstore(0, nonIndexed)
                    log3(0, 0x20, signatureHash, indexed1, indexed2)
                }

                /* -------- storage layout ---------- */
                function ownerPos() -> p { p := 0 }
                function totalSupplyPos() -> p { p := 1 }
                function accountToStorageOffset(account) -> offset {
                    offset := add(0x1000, account)
                }
                function allowanceStorageOffset(account, spender) -> offset {
                    offset := accountToStorageOffset(account)
                    mstore(0, offset)
                    mstore(0x20, spender)
                    offset := keccak256(0, 0x40)
                }

                /* -------- storage access ---------- */
                function owner() -> o {
                    o := sload(ownerPos())
                }
                function totalSupply() -> supply {
                    supply := sload(totalSupplyPos())
                }
                function mintTokens(amount) {
                    sstore(totalSupplyPos(), safeAdd(totalSupply(), amount))
                }
                function balanceOf(account) -> bal {
                    bal := sload(accountToStorageOffset(account))
                }
                function addToBalance(account, amount) {
                    let offset := accountToStorageOffset(account)
                    sstore(offset, safeAdd(sload(offset), amount))
                }
                function deductFromBalance(account, amount) {
                    let offset := accountToStorageOffset(account)
                    let bal := sload(offset)
                    require(lte(amount, bal))
                    sstore(offset, sub(bal, amount))
                }
                function allowance(account, spender) -> amount {
                    amount := sload(allowanceStorageOffset(account, spender))
                }
                function setAllowance(account, spender, amount) {
                    sstore(allowanceStorageOffset(account, spender), amount)
                }
                function decreaseAllowanceBy(account, spender, amount) {
                    let offset := allowanceStorageOffset(account, spender)
                    let currentAllowance := sload(offset)
                    require(lte(amount, currentAllowance))
                    sstore(offset, sub(currentAllowance, amount))
                }

                /* ---------- utility functions ---------- */
                function lte(a, b) -> r {
                    r := iszero(gt(a, b))
                }
                function gte(a, b) -> r {
                    r := iszero(lt(a, b))
                }
                function safeAdd(a, b) -> r {
                    r := add(a, b)
                    if or(lt(r, a), lt(r, b)) { revert(0, 0) }
                }
                function calledByOwner() -> cbo {
                    cbo := eq(owner(), caller())
                }
                function revertIfZeroAddress(addr) {
                    require(addr)
                }
                function require(condition) {
                    if iszero(condition) { revert(0, 0) }
                }
            }
        }
    }
