##################################
عبارات و ساختارهای کنترلی
##################################

.. index:: ! parameter, parameter;input, parameter;output, function parameter, parameter;function, return variable, variable;return, return


.. index:: if, else, while, do/while, for, break, continue, return, switch, goto

ساختارهای کنترلی (Control Structures)
===================

بیشتر ساختارهای کنترلی که از زبان‌های آکولادی  شناخته شده‌اند در سالیدیتی موجود می‌باشند:

ساختارهایی که وجود دارند: ``if`` ، ``else`` ، ``while`` ، ``do`` ، ``for`` ، ``break`` ، ``continue`` ، ``return`` ، با سمنتیک  متداول شناخته شده در C یا JavaScript..

سالیدیتی همچنین از مدیریت اکستنشن  در قالب دستور  ``try`` / ``catch`` پشتیبانی می‌کند، اما فقط برای 
:ref:`فراخوانی تابع خارجی<external-function-calls>` و فراخوانی ایجاد قرارداد. خطاها را می‌توان با استفاده از دستور :ref:`revert statement <revert-statement>` ایجاد کرد.

پرانتز  را نمی‌توان برای شرطی‌ها حذف کرد‌، اما آکولادها  را می‌توان در اطراف بادی‌های تک دستوری  حذف کرد.


توجه داشته باشید که هیچ تبدیل تایپی از تایپ غیر بولی به تایپ بولی همانطور که در C و جاوا اسکریپت وجود 
دارند در سالیدیتی وجود ندارد، بنابراین ``if (1) { ... }``  در سالیدیتی معتبر *نیست*.


.. index:: ! function;call, function;internal, function;external

.. _function-calls:

فراخوانی‌های تابع
==============

.. _internal-function-calls:

فراخوانی تابع داخلی (Internal Function Calls)
-----------------------

توابع قرارداد فعلی را می‌توان مستقیماً ("داخلی ") و همچنین به صورت بازگشتی نامید، همانطور که در این مثال بی معنی نشان داده شده است:



.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.4.22 <0.9.0;

    // This will report a warning
    contract C {
        function g(uint a) public pure returns (uint ret) { return a + f(); }
        function f() internal pure returns (uint ret) { return g(7) + f(); }
    }

این فراخوانی‌های تابع به jumpهای ساده در داخل EVM ترجمه می‌شود. این امر باعث می‌شود که مِمُوری 
فعلی پاک نشود، یعنی ارسال رفرنس‌های مِمُوری به توابع داخلی که بسیار کارآمد هستند. فقط توابع یک 
instance  قرارداد می‌توانند به صورت داخلی فراخوانی شوند.


شما همچنان باید از بازگشت بیش از حد اجتناب کنید، زیرا هر فراخوانی تابع داخلی حداقل از یک اسلات  پشته 
استفاده می‌کند و فقط 1024 اسلات در دسترس است.

.. _external-function-calls:

فراخوانی تابع خارجی (External Function Calls)
-----------------------

توابع را می توان با استفاده از نمادگذاری   ``;this.g(8)`` و  ``;c.g(2)`` نیز فراخوانی کرد. که در 
آن ``c`` یک قرارداد  instance  و ``g`` تابعی است که متعلق به  ``c`` است. فراخوانی تابع ``g`` با استفاده از 
message call و نه مستقیماً از طریق jump ها، از هر دو طرف منجر به فراخوانی آن به صورت " externally" می‌شود. 
لطفاً توجه داشته باشید که فراخوانی‌های تابع روی  ``this`` را نمی توان در کانستراکتور (constructor) استفاده کرد، زیرا قرارداد فعلی هنوز ایجاد نشده است.

توابع سایر قراردادها باید خارجی نامیده شود. برای یک فراخوانی خارجی، همه آرگومان‌های تابع باید در مِمُوری 
کپی شوند.


.. note::

    فراخوانی تابع از یک قرارداد به قرارداد دیگر تراکنش خود را ایجاد نمی‌کند، بلکه یک مسیج کال به عنوان 
    بخشی از کل تراکنش است.

    

هنگام فراخوانی توابع سایر قراردادها، می توانید مقدار Wei یا گاز ارسال شده با فراخوانی آپشن‌های  
خاص   ``{value: 10, gas: 10000}`` تعیین کنید. توجه داشته باشید که تعیین مقادیر گاز به طور 
واضح توصیه نمی‌شود، زیرا هزینه گازهای آپکد در آینده می‌تواند تغییر کند. هر Wei که به قرارداد ارسال 
می‌کنید به کل موجودی آن قرارداد اضافه می‌شود:



.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.6.2 <0.9.0;

    contract InfoFeed {
        function info() public payable returns (uint ret) { return 42; }
    }

    contract Consumer {
        InfoFeed feed;
        function setFeed(InfoFeed addr) public { feed = addr; }
        function callFeed() public { feed.info{value: 10, gas: 800}(); }
    }
شما باید از اصلاح کننده   ``payable`` با تابع  ``info`` استفاده کنید زیرا در غیر این صورت، 
آپشن  ``value`` در دسترس نخواهد بود.

.. warning::

مراقب باشید ``feed.info{value: 10, gas: 800}``  فقط  ``value`` و مقدار  ``gas`` ارسال 
شده با فراخوانی تابع را به صورت محلی تعیین کند و پرانتز در انتها فراخوانی واقعی  را انجام دهد. 
بنابراین  ``feed.info{value: 10, gas: 800}``   تابع را فراخوانی نمی‌کند و تنظیمات ``value`` و ``gas`` از بین 
می‌رود، فقط  ``()feed.info{value: 10, gas: 800}`` فراخوانی تابع را انجام می‌دهد.

با توجه به این واقعیت که EVM فراخوانی با یک قرارداد غیر موجود را همیشه موفق می‌داند، سالیدیتی از 
آپکد  ``extcodesize`` استفاده می‌کند تا بررسی کند که قراردادی که قرار است فراخوانی شود واقعاً وجود 
دارد (حاوی کد است) و در صورت عدم وجود اکستنشن  ایجاد می‌کند. توجه داشته باشید که این بررسی در مورد 
:ref:`فراخوانی‌های سطح پایین<address_related>` که به جای قرارداد instances روی آدرس‌ها کار می‌کنند، انجام نمی‌شود.

اگر قرارداد فراخوانی شده خودش یک اکستنشن ایجاد کند یا گاز تمام شود، توابع فراخوانی باعث ایجاد اکستنشن می‌شوند.

.. warning::

    هرگونه تعامل با قرارداد دیگر خطر بالقوه‌ای را تحمیل می‌کند، به ویژه اگر سورس کد قرارداد از قبل مشخص 
    نباشد. قرارداد فعلی کنترل را به قرارداد فراخوانی شده می‌سپارد و ممکن است تقریباً هر کاری را انجام دهد. 
    حتی اگر قرارداد فراخوانی شده از قرارداد والد شناخته شده ارث بری کند، قرارداد وارث باید فقط دارای 
    اینترفیس صحیح باشد. پیاده سازی قرارداد، بدین ترتیب، می‌تواند کاملاً دلخواه باشد و در نتیجه، خطری ایجاد 
    کند. علاوه بر این، آماده باشید در صورتی که قبل از بازگشت اولین فراخوانی، قراردادهای دیگر سیستم شما را 
    فراخواند یا حتی به قرارداد  بازگردد. این بدان معناست که قرارداد فراخوانی شده می‌تواند متغیرهای حالت 
    قرارداد فراخوانی را از طریق توابع خود تغییر دهد. توابع خود را به گونه ای بنویسید که برای مثال، فراخوانی 
    به توابع خارجی پس از هرگونه تغییر در متغیرهای حالت در قرارداد شما اتفاق بیفتد تا قرارداد شما در برابر 
    سوء استفاده مجدد آسیب پذیر نباشد.


.. note::

    قبل از  سالیدیتی 0.6.2 ، روش توصیه شده برای تعیین مقدار و گاز استفاده 
    از  ``()f.value(x).gas(g)`` بود. این در سالیدیتی 0.6.2 منسوخ شد و دیگر از سالیدیتی 0.7.0 دیگر امکان پذیر نیست.


فراخوان‌های نامگذاری شده و پارامترهای تابع ناشناس 
---------------------------------------------

آرگومان‌های فراخوانی تابع را می‌توان با نام، به هر ترتیب، در صورتی که در ``{ }``  محصور شده باشد، ارائه دهید، 
همانطور که در مثال زیر مشاهده می‌شود. لیست آرگومان باید توسط نام با پارامترهای اعلان تابع منطبق شود، 
اما می‌تواند به ترتیب دلخواه باشد.


.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.4.0 <0.9.0;

    contract C {
        mapping(uint => uint) data;

        function f() public {
            set({value: 2, key: 3});
        }

        function set(uint key, uint value) public {
            data[key] = value;
        }

    }

نام پارامترهای تابع حذف شده
--------------------------------

نام پارامترهای استفاده نشده (به ویژه پارامترهای برگشتی) را می توان حذف کرد. این پارامترها هنوز روی پشته 
وجود دارند، اما قابل دسترسی نیستند.


.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.4.22 <0.9.0;

    contract C {
        // omitted name for parameter
        function func(uint k, uint) public pure returns(uint) {
            return k;
        }
    }


.. index:: ! new, contracts;creating

.. _creating-contracts:

ایجاد قراردادها از طریق قرارداد  ``new``
==============================

یک قرارداد می‌تواند قراردادهای دیگری با استفاده از کلمه کلیدی  ``new`` ایجاد کند. کد کامل قرارداد ایجاد شده 
باید هنگام تنظیم قرارداد ایجاد شده مشخص شود، بنابراین وابستگی‌های ایجاد بازگشتی  امکان پذیر نیستند.


.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.7.0 <0.9.0;
    contract D {
        uint public x;
        constructor(uint a) payable {
            x = a;
        }
    }

    contract C {
        D d = new D(4); // will be executed as part of C's constructor

        function createD(uint arg) public {
            D newD = new D(arg);
            newD.x();
        }

        function createAndEndowD(uint arg, uint amount) public payable {
            // Send ether along with the creation
            D newD = new D{value: amount}(arg);
            newD.x();
        }
    }

همانطور که در مثال مشاهده می‌شود، امکان ارسال اتر در هنگام ایجاد یک 
instance از  ``D`` با استفاده از گزینه  ``value`` وجود دارد، اما امکان محدود کردن مقدار گاز وجود ندارد. اگر 
ایجاد شکست خورد (به دلیل out-of-stack ، عدم وجود بالانس کافی یا مشکلات دیگر)، یک اکستنشن  
اعمال می‌شود.


قرارداد ایجاد Salted / create2
-----------------------------------

هنگام ایجاد یک قرارداد، آدرس قرارداد از آدرس قرارداد ایجاد کننده محاسبه می‌شود و یک شمارنده که با ایجاد 
هر قرارداد افزایش می‌یابد.


اگر گزینه  ``salt``  (مقدار bytes32) را مشخص کنید، در ایجاد قرارداد از مکانیزمی متفاوت برای ارائه آدرس 
قرارداد جدید استفاده می‌شود:


آدرس را از آدرس قرارداد ایجاد کننده، مقدار  salt داده شده، بایت‌کد ایجاد (creation) قرارداد ایجاد شده 
و آرگومان‌های کانستراکتور (constructor) را محاسبه می‌کند.

به طور خاص، شمارنده ("nonce") استفاده نمی‌شود. این امر باعث ایجاد انعطاف پذیری بیشتری در ایجاد 
قراردادها می شود: شما می‌توانید آدرس قرارداد جدید را قبل از ایجاد آن بدست آورید. علاوه بر این، در صورتی 
که قراردادهای ایجاد کننده در meantime قراردادهای دیگری ایجاد کنند، می‌توانید به این آدرس نیز اعتماد 
کنید.


مورد اصلی استفاده در اینجا قراردادهایی است که به عنوان قاضی  برای تراکنش‌های خارج از زنجیره عمل 
می‌کنند، که فقط در صورت بروز اختلاف باید ایجاد شود.


.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.7.0 <0.9.0;
    contract D {
        uint public x;
        constructor(uint a) {
            x = a;
        }
    }

    contract C {
        function createDSalted(bytes32 salt, uint arg) public {
            // This complicated expression just tells you how the address
            // can be pre-computed. It is just there for illustration.
            // You actually only need ``new D{salt: salt}(arg)``.
            address predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(
                bytes1(0xff),
                address(this),
                salt,
                keccak256(abi.encodePacked(
                    type(D).creationCode,
                    arg
                ))
            )))));

            D d = new D{salt: salt}(arg);
            require(address(d) == predictedAddress);
        }
    }

.. warning::

    یک سری ویژگی‌های مربوط به  salted creationوجود دارد. پس از از بین رفتن، می‌توان یک قرارداد را 
    در همان آدرس دوباره ایجاد کرد. با این وجود، آن قرارداد تازه ایجاد شده ممکن است دارای بایت‌کد دیپلوی 
    شده متفاوتی باشد، حتی اگر بایت‌کد ایجاد شده یکسان بوده‌ (که الزامی است زیرا در غیر این صورت آدرس 
    تغییر می‌کند). به این دلیل است که کامپایلر می‌تواند وضعیت خارجی را که ممکن است بین دو creations 
    تغییر کرده باشد، جستجو کند و قبل از ذخیره آن را در بایت‌کد دیپلوی شده ادغام کند.

ترتیب ارزیابی عبارات
==================================

ترتیب ارزیابی عبارات مشخص نشده‌است (به طور رسمی، ترتیب ارزیابی فرزندان یک گره  در درخت عبارت 
مشخص نشده است، اما آنها البته قبل از خود گره ارزیابی می‌شوند). فقط تضمین می‌شود که دستورات به ترتیب 
اجرا شوند و اتصال کوتاه  برای عبارات بولی انجام شود.


.. index:: ! assignment

تخصیص (Assignment)
==========

.. index:: ! assignment;destructuring

تخریب Assignment ها و برگرداندن چندین مقدار 
-------------------------------------------------------

سالیدیتی به صورت داخلی به تایپ‌های تاپل  اجازه می‌دهد، مانند لیستی از اشیاء از تایپ‌های مختلف که تعداد 
آنها در زمان کامپایل ثابت است. از این تاپل‌ها می‌توان برای برگرداندن چندین مقدار به طور همزمان استفاده 
کرد. سپس این متغیرها را می‌توان به متغیرهای اعلام شده جدید یا به متغیرهای از قبل موجود (یا به طور کلی 
) اختصاص داد.


تاپل‌ها در سالیدیتی تایپ‌های مناسبی نیستند، آنها فقط می‌توانند برای تشکیل گروه بندی سینتکس  عبارات 
استفاده شوند.



.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.5.0 <0.9.0;

    contract C {
        uint index;

        function f() public pure returns (uint, bool, uint) {
            return (7, true, 2);
        }

        function g() public {
            // Variables declared with type and assigned from the returned tuple,
            // not all elements have to be specified (but the number must match).
            (uint x, , uint y) = f();
            // Common trick to swap values -- does not work for non-value storage types.
            (x, y) = (y, x);
            // Components can be left out (also for variable declarations).
            (index, , ) = f(); // Sets the index to 7
        }
    }

نمی‌توان اعلان‌های متغیر و assignmentهای بدون اعلان را مخلوط کر ، یعنی موارد زیر معتبر 
نیست:  ``; (1, 2)= (x, uint y)``



.. note::

    تا قبل از نسخه 0.5.0 امکان تعیین تعداد زیادی از اندازه‌های کوچکتر وجود داشت، چه در سمت چپ و چه 
    در سمت راست (که همیشه خالی بود). این در حال حاضر ممنوع است، بنابراین هر دو طرف باید تعداد 
    کامپوننت‌های یکسانی داشته باشند.



.. warning::

    هنگام اختصاص دادن چند متغیر به طور همزمان هنگامی که انواع مرجع درگیر هستند، مراقب باشید، زیرا 
    ممکن است منجر به رفتار کپی غیر منتظره شود.

 

عوارض آرایه‌ها و ساختارها
------------------------------------

سمنتیک assignment ها برای تایپ‎‌های non-value مانند آرایه‌ها و ساختارها، از جمله  ``bytes`` 
و  ``string``  پیچیده تر است، برای اطلاعات بیشتر به قسمت  :ref:`Data location و assignment behaviour <data-location-assignment>` 
مراجعه کنید.



در مثال زیر فراخوانی  ``g(x)`` هیچ تاثیری بر روی  ``x`` ندارد زیرا یک کپی مستقل از مقدار storage در 
مِمُوری ایجاد می‌کند. با این حال،  ``h(x)`` با موفقیت  ``x`` را تغییر می‌دهد زیرا فقط یک رفرنس منتقل می‌شود 
و نه یک کپی.



.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.4.22 <0.9.0;

    contract C {
        uint[20] x;

        function f() public {
            g(x);
            h(x);
        }

        function g(uint[20] memory y) internal pure {
            y[2] = 3;
        }

        function h(uint[20] storage y) internal {
            y[3] = 4;
        }
    }

.. index:: ! scoping, declarations, default value

.. _default-value:

محدوده سازی و اعلامیه‌ها  (Scoping and Declarations)
========================

متغیری که اعلام می‌شود دارای مقدار پیش فرض اولیه است که نمایش بایت آن همه صفر است. "مقادیر پیش 
فرض" متغیرها  نوعی "حالت صفر" هر تایپ است. به عنوان مثال، مقدار پیش فرض  ``bool`` ،  ``false`` است. 
مقدار پیش فرض برای انواع  ``uint`` یا  ``int`` ،  ``0`` است. برای آرایه‌ها با اندازه استاتیک و ``bytes1``  
تا  ``bytes32`` ، هر عنصر جداگانه با مقدار پیش فرض مربوط به نوع خود مقداردهی می‌شود. برای آرایه‌ها با 
اندازه داینامیک، ``bytes``  و  ``string`` ، مقدار پیش فرض یک آرایه یا رشته خالی است. برای نوع  ``enum`` ، 
مقدار پیش فرض اولین عضو آن است.


محدوده سازی در سالیدیتی از قوانین گسترده محدوده C99 (و بسیاری از زبان‌های دیگر) پیروی می‌کند: 
متغیرها از نقطه بعد از اعلام آنها تا پایان کوچکترین بلوک  ``{ }`` که حاوی اعلان است قابل مشاهده هستند. به 
عنوان یک استثنا از این قاعده، متغیرهای اعلام شده در قسمت مقداردهی اولیه حلقه for فقط تا انتهای حلقه 
for قابل مشاهده هستند.



متغیرهایی مانند پارامترها (پارامترهای تابع، پارامترهای modifier، پارامترهای catch، ...) در داخل بلوک کد 
زیر قابل مشاهده هستند - بدنه تابع/ modifier برای پارامتر تابع و modifier و بلوک catch برای پارامتر catch.



متغیرها و سایر موارد اعلام شده در خارج از یک بلوک کد، به عنوان مثال توابع، قراردادها، تایپ‌های تعریف شده 
توسط کاربر و غیره، حتی قبل از اعلام شدن قابل مشاهده هستند. این بدان معناست که می‌توانید متغیرهای 
حالت را قبل از اعلان استفاده کرده و توابع را به صورت بازگشتی فراخوانی کنید.


در نتیجه، مثال‌های زیر بدون هشدار کامپایل می‌شوند، زیرا این دو متغیر دارای نام یکسانی هستند اما محدوده‌های جدا از هم ندارند.


.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.5.0 <0.9.0;
    contract C {
        function minimalScoping() pure public {
            {
                uint same;
                same = 1;
            }

            {
                uint same;
                same = 3;
            }
        }
    }

به عنوان یک مثال ویژه از قوانین محدوده C99 ، توجه داشته باشید که در ادامه، اولین تخصیص به  ``x`` در واقع 
متغیر بیرونی را تعیین می‌کند نه داخلی را. در هر صورت، هشدار در مورد پنهان بودن متغیر خارجی دریافت 
خواهید کرد.


.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.5.0 <0.9.0;
    // This will report a warning
    contract C {
        function f() pure public returns (uint) {
            uint x = 1;
            {
                x = 2; // this will assign to the outer variable
                uint x;
            }
            return x; // x has value 2
        }
    }

.. warning::

    قبل از نسخه سالیدیتی 0.5.0 از قوانین محدوده سازی جاوا اسکریپت پیروی می‌کرد، یعنی متغیری که در هر 
    نقطه از یک تابع اعلام می‌شود، برای کل تابع، صرف نظر از جایی که اعلام شده است، محدوده دارد. مثال زیر 
    قطعه کد  را نشان می‌دهد که برای کامپایل استفاده می‌شود اما منجر به خطایی می‌شود که از نسخه 0.5.0 
    شروع می‌شود.

   

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.5.0 <0.9.0;
    // This will not compile
    contract C {
        function f() pure public returns (uint) {
            x = 2;
            uint x;
            return x;
        }
    }


.. index:: ! safe math, safemath, checked, unchecked
.. _unchecked:

محاسبه Checked  یا  Unchecked
===============================

overflow  یا  underflow وضعیتی است که در آن مقدار حاصله از یک عملیات حسابی، هنگامی که بر 
روی یک اینتیجر  نامحدود اجرا می‌شود، از محدوده نتیجه تایپ خارج می‌شود.



قبل از سالیدیتی 0.8.0 ، عملیات حسابی همیشه در صورت overflow  یا  underflow شدن منجر به 
استفاده گسترده از کتابخانه هایی می‌شود که چک‌های اضافی  را ایجاد می‌کنند.



از سالیدیتی 0.8.0، همه عملیات حسابی به طور پیش فرض روی overflow و underflow برمی‌گردند، 
بنابراین استفاده از این کتابخانه‌ها غیر ضروری می‌شود.



برای به دست آوردن رفتار قبلی، می‌توان از یک بلوک  ``unchecked`` استفاده کرد:


.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity ^0.8.0;
    contract C {
        function f(uint a, uint b) pure public returns (uint) {
            // This subtraction will wrap on underflow.
            unchecked { return a - b; }
        }
        function g(uint a, uint b) pure public returns (uint) {
            // This subtraction will revert on underflow.
            return a - b;
        }
    }

فراخوانی  ``f(2, 3)`` ،  ``2**256-1``  خواهد برگردان، در حالی  که  ``g(2, 3)``  باعث اعلان  ناموفق خواهد شد.

بلوک  ``unchecked`` می‌تواند در همه جا در داخل یک بلوک استفاده شود، اما نه به عنوان جایگزینی برای یک بلوک. همچنین نمی‌تواند تو در تو باشد.


این تنظیمات فقط برای دستوراتی که از لحاظ سمنتیکی در داخل بلوک قرار دارند تأثیر می‌گذارد. توابع 
فراخوانی شده از داخل یک بلوک  ``unchecked`` ویژگی را به ارث نمی برند.



.. note::

    برای جلوگیری از ابهام، نمی‌توانید از  ``;_`` داخل یک بلوک  ``unchecked`` استفاده کنید.  

   

عملگرهای زیر اعلان ناموفق در overflow  یا  underflow را ایجاد می‌کنند و در صورت استفاده در یک 
بلوک unchecke بدون خطا بسته بندی  می‌شوند:


``++`` ، ``--`` ، ``+`` ،``-`` binary ``-`` ، unary  ، ``*`` ، ``/`` ، ``%`` ، ``**``

``=+`` ، ``=-`` ، ``=*`` ، ``=/`` ، ``=%``

.. warning::

    با استفاده از بلوک  unchecked نمی‌توان بررسی تقسیم بر صفر یا باقیمانده بر صفر را غیرفعال کرد.


.. note::

    عملگرهای بیتی چک های سرریز یا سرریز را انجام نمی دهند. این امر به ویژه در هنگام استفاده از شیفت های 
    بیتی ( ``<<`` , ``>>`` , ``=<<`` , ``=>>`` ) به جای تقسیم عدد صحیح و ضرب در توان 2 قابل مشاهده است. به عنوان 
    مثال ``type(uint256).max << 3``  باز نمی گردد حتی 
    اگر  ``type(uint256).max * 8`` باشد.


.. note::

    عبارت دوم در  ``;int x = type(int).min; -x`` منجر به overflow می‌شود زیرا محدوده 
    منفی می‌تواند یک مقدار بیشتر از محدوده مثبت را در خود نگه دارد.


تبدیل‌های تایپ صریح  همیشه کوتاه می‌شوند و هرگز باعث ایجاد اعلان ناموفق با اکسپشنی  از تبدیل اینتیجر 
به تایپ  enum نمی‌شوند.



.. index:: ! exception, ! throw, ! assert, ! require, ! revert, ! errors

.. _assert-and-require:

مدیریت خطا: ادعا ، درخواست، بازگشت و اکسپشن‌ها (Exceptions)
======================================================

سالیدیتی از اکسپشن برگرداندن حالت  برای مدیریت خطاها استفاده می‌کند. چنین اکسپشنی همه تغییرات 
ایجاد شده در وضعیت را در فراخوانی فعلی(و همه فراخوانی‌های فرعی آن) لغو می‌کند و خطایی را برای فراخوانی 
کننده نشان می‌دهد.



وقتی اکسپشنی در یک فراخوانی فرعی اتفاق می‌افتد، آنها به طور خودکار "نمایش داده می‎شوند " (به عنوان 
مثال، اکسپشن‌های دوباره بازیابی می‌شوند) مگر اینکه در دستور  ``try/catch`` گیر کرده باشند. اکسپشن 
این قاعده عبارتند از  ``send`` و توابع سطح پایین ``call`` ، ``delegatecall`` و ``staticcall`` : آنها 
در صورت اکسپشن به جای "نمایش اکسپشن" به عنوان اولین مقدار بازگشتی،  ``false`` را برمی‌گردانند.


.. warning::

    توابع سطح پایین ``call`` ، ``delegatecall`` و ``staticcall`` به عنوان بخشی از طراحی EVM به 
    عنوان اولین مقدار بازگشتی خود در صورتی که اکانت فراخوانی شده وجود نداشته باشد، ``true`` را 
    برمیگردانند. در صورت نیاز قبل از فراخوانی باید وجود اکانت را بررسی کنید.


اکسپشن می‌توانند شامل داده‌های خطا باشند که در قالب :ref:`error instances <errors>`  به فراخوانی کننده برگردانده 
می‌شوند. خطاهای داخلی  ``Error(string)`` و  ``Panic(uint256)`` توسط توابع خاصی استفاده 
می شود ، همانطور که در زیر توضیح داده شده است.  ``Error`` برای شرایط خطای "معمولی" استفاده می شود 
در حالی که  ``Panic`` برای خطاهایی استفاده می شود که نباید در کد عاری از اشکال وجود داشته باشد.


Panic از طریق  ``assert`` و خطا از طریق ``require``
----------------------------------------------

توابع راحت ``assert``  و ``require``  را می‎توان برای بررسی شرایط و حذف اکسپشن در صورت برآورده نشدن شرایط استفاده کرد.



تابع assert  خطایی از نوع  ``Panic(uint256)`` ایجاد می‌کند. همان خطا توسط کامپایلر در شرایط خاصی ایجاد می‌شود که در زیر ذکر شده است.



Assert فقط باید برای آزمایش خطاهای داخلی و بررسی تغییرات متغیر استفاده شود. کد در حال کار مناسب، 
هرگز نباید Panic ایجاد کند، حتی در ورودی خارجی نامعتبر. اگر این اتفاق بیفتد، در قرارداد شما اشکالی وجود 
دارد که باید آن را برطرف کنید. ابزارهای آنالیز زبان می‌توانند قرارداد شما را برای شناسایی شرایط و فراخوانی‌های 
تابع که باعث Panic می‌شود، ارزیابی کنند.



یک اکسپشن Panic در شرایط زیر ایجاد می‌شود. کد خطای ارائه شده با داده‌های خطا نشان دهنده نوعی Panic است.


#.  0x00: برای کامپایلر عمومیِ panic های درج شده استفاده می‌شود.
#.	0x01: اگر ``assert``  را با آرگومانی که false ارزیابی می‌کند فراخوانی کنید.
#.	0x11: اگر یک عملیات حسابی منجر به underflow  یا  overflow خارج از یک بلوک ``{ ... }unchecked``   شود.
#.	0x12 ؛ اگر مقدار را تقسیم یا باقیمانده بر صفر کنید (برای مثال ``5 / 0`` یا ``23 % 0``).
#.	0x21: اگر مقدار خیلی بزرگ یا منفی را به تایپ enum تبدیل کنید.
#.	0x22: اگر به آرایه بایت storage که به نادرستی کدگذاری شده است دسترسی داشته باشید.
#.	0x31: اگر  ``()pop.`` را در یک آرایه خالی فراخوانی کنید.
#.	0x32: اگر به یک آرایه،  ``bytesN`` یا یک برش آرایه در نمای خارج از محدوده یا منفی دسترسی داشته باشید (یعنی  ``x[i]`` جایی که ``i >= x.length  یا  i < 0`` ).
#.	0x41: اگر مقدار زیادی مِمُوری اختصاص دهید یا یک آرایه بسیار بزرگ ایجاد کنید.
#.	0x51: در صورت فراخوانی متغییر zero-initialized از تایپ تابع داخلی.


تابع  ``require`` یا خطایی بدون هیچ گونه داده یا خطایی از نوع ``Error(string)`` ایجاد می‌کند. باید 
برای اطمینان از شرایط معتبری که تا زمان اجرا قابل تشخیص نیستند مورد استفاده قرار گیرد. این شامل شرایط 
ورودی‌ها یا بازگشت مقادیر از فراخوانی‌ها به قراردادهای خارجی است.


.. note::

// @saracodic cst
s
    در حال حاضر امکان استفاده از خطاهای سفارشی در ترکیب با  ``require`` وجود ندارد. لطفا از بجای آن 
    از  ``;if(!condition) revert CustomError()`` استفاده کنید.

    It is currently not possible to use custom errors in combination
    with ``require``. Please use ``if (!condition) revert CustomError();`` instead.

یک اکسپشن ``Error(string)``  (یا یک اکسپشن بدون داده) توسط کامپایلر در شرایط زیر ایجاد می‌شود:




#.	فراخوانی  ``require(x)``  در جایی که ``x``  به صورت  ``false`` ارزیابی شود.
#.	اگر از  ``()revert`` یا  ``revert("description")`` استفاده کنید.
#.	اگر یک تابع فراخوانی خارجی اجرا کنید که قراردادی را که فاقد کد است را هدف قرار می‌دهد.
#.	اگر قرارداد شما اتر را از طریق یک تابع public بدون اصلاح کننده   ``payable``  (شامل کنستراکتور و تابع fallback) دریافت ‌کند.
#.	اگر قرارداد شما اتر را از طریق یک تابع گیرنده  publicدریافت کند.


در موارد زیر، داده‌ خطا  از فراخوانی خارجی (در صورت ارائه) ارسال می‌شوند. این بدان معناست که می‌تواند باعث `Error` یا  `Panic` شود (یا هر چیز دیگری که داده شد):



1.	اگر  ``()transfer.`` با شکست مواجه شود.
2.	اگر یک تابع را از طریق یک message call فراخوانی می‌کنید اما به درستی به پایان نمی‌رسد (یعنی گاز آن تمام می‌شود، هیچ تابع matching ندارد یا خود یک اکسپشن ایجاد نمی‌کند)، مگر در مواردی که یک عملیات سطح پایین  ``call`` ، ``send`` ، ``delegatecall`` ، ``callcode`` یا  ``staticcall`` استفاده شود عملیات سطح پایین هرگز اکسپشن ایجاد نمی‌کند، اما با بازگشت  ``false``  نشان دهنده شکست است.
3.	اگر قراردادی با استفاده از کلمه کلیدی  ``new`` ایجاد ‌کنید  :ref:`اما ایجاد قرارداد به درستی به پایان نرسد<creating-contracts>`.


به صورت اختیاری می‌توانید یک رشته پیام برای  ``require`` ارائه دهید، اما نه برای  ``assert`` .



.. note::

    اگر آرگومان رشته‌ای  ``requir`` را ارائه ندهید، با خطای داده خالی، حتی نه شامل انتخاب کننده خطا، باز میگردد.

    If you do not provide a string argument to ``require``, it will revert
    with empty error data, not even including the error selector.

مثال زیر نشان می‌دهد که چگونه می‌توانید از   ``require`` برای بررسی شرایط ورودی‌ها و  ``assert`` برای بررسی خطای داخلی استفاده کنید.

The following example shows how you can use ``require`` to check conditions on inputs
and ``assert`` for internal error checking.

.. code-block:: solidity
    :force:

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.5.0 <0.9.0;

    contract Sharer {
        function sendHalf(address payable addr) public payable returns (uint balance) {
            require(msg.value % 2 == 0, "Even value required.");
            uint balanceBeforeTransfer = address(this).balance;
            addr.transfer(msg.value / 2);
            // Since transfer throws an exception on failure and
            // cannot call back here, there should be no way for us to
            // still have half of the money.
            assert(address(this).balance == balanceBeforeTransfer - msg.value / 2);
            return address(this).balance;
        }
    }

به طور داخلی، سالیدیتی یک عملیات بازگشت را انجام می‌دهد (دستور  ``0xfd``). این امر باعث می‌شود EVM 
تمام تغییرات ایجاد شده در حالت را برگرداند. دلیل بازگشت این است که هیچ راه مطمئنی برای ادامه اجرا وجود 
ندارد، زیرا اثر مورد انتظار رخ نداده است. از آنجا که ما می‌خواهیم atomicity  تراکنش‌ها را حفظ کنیم، مطمئن 
ترین اقدام این است که همه تغییرات را برگردانیم و کل تراکنش (یا حداقل فراخوانی) را بدون تأثیر انجام دهیم.


در هر دو حالت، فراخوانی کننده می‌تواند با استفاده از ``try``/``catch`` واکنش نشان دهد، اما تغییرات در 
فراخوانی گیرنده همیشه برمی‌گردد.


.. note::

    اکسپشن Panic برای استفاده از آپکد  ``invalid`` قبل از سالیدیتی 0.8.0، که تمام گاز موجود در 
    فراخوانی را مصرف می‌کرد، استفاده میشد. اکسپشن‌ها ``require`` تا قبل از انتشار متروپلیس  برای مصرف 
    تمام گاز استفاده میشد.


.. _revert-statement:

``revert``
----------

revert مستقیم را می‌توان با استفاده از دستور  ``revert`` و تابع  ``revert`` فعال کرد.


دستور  ``revert`` یک خطای سفارشی را به عنوان آرگومان مستقیم و بدون پرانتز می‌گیرد:



    ;revert CustomError(arg1, arg2)

به دلایل سازگاری backards ، تابع  ``()revert`` نیز وجود دارد که از پرانتز استفاده می‌کند و یک رشته را می‌پذیرد:



    ;revert()
    ;revert("description")

داده‌های خطا به فراخوانی کننده گیرنده منتقل می‌شود و در آنجا قابل مشاهده است. استفاده از ``()revert``  
باعث می‌شود بدون هیچ گونه داده خطایی یک بازگشت وجود داشته باشد در حالی 
که  ``revert("description")`` خطای  ``Error(string)`` ایجاد می‌کند.

معمولاً استفاده از خطای instance سفارشی بسیار ارزانتر از توصیف رشته است، زیرا می‌توانید از نام خطا برای 
توصیف آن استفاده کنید، که فقط در چهار بایت کدگذاری شده است. توضیحات طولانی‌تری را می‍توان از طریق 
NatSpec ارائه کرد که هیچ هزینه‌ای را متحمل نمی‌شود.


مثال زیر نحوه استفاده از یک رشته خطا و یک نمونه خطای سفارشی را همراه با  ``revert`` و معادل  ``require`` نشان می‌دهد:



.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity ^0.8.4;

    contract VendingMachine {
        address owner;
        error Unauthorized();
        function buy(uint amount) public payable {
            if (amount > msg.value / 2 ether)
                revert("Not enough Ether provided.");
            // Alternative way to do it:
            require(
                amount <= msg.value / 2 ether,
                "Not enough Ether provided."
            );
            // Perform the purchase.
        }
        function withdraw() public {
            if (msg.sender != owner)
                revert Unauthorized();

            payable(msg.sender).transfer(address(this).balance);
        }
    }

دو راه  ``;(...)if (!condition) revert`` و ``;require(condition, ...)`` معادل 
هستند تا زمانی که آرگومان‌ها برای  ``revert`` و  ``require`` عوارض جانبی نداشته باشند، به عنوان مثال اگر فقط string باشند.
 


.. note::
    تابع مورد  ``require`` نیز مانند سایر عملکردها ارزیابی می شود. این بدان معناست که همه آرگومان ها قبل 
    از اجرای خود تابع ارزیابی می شوند. به طور خاص ، در  ``require(condition, f())`` تابع  ``f`` 
    اجرا می‌شود حتی اگر  ``condition`` درست باشد.



رشته ارائه شده به گونه‌ای :ref:`abi-encoded <ABI>`  می‌شود که انگار یک فراخوانی به یک تابع  ``Error(string)`` است. 
در مثال بالا،  ``;revert("Not enough Ether provided.")`` داده‌های هگزا دسیمال زیر را 
به عنوان داده‌های بازگشت خطا بر میگرداند:



.. code::

    0x08c379a0                                                         // Function selector for Error(string)
    0x0000000000000000000000000000000000000000000000000000000000000020 // Data offset
    0x000000000000000000000000000000000000000000000000000000000000001a // String length
    0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // String data

مطابق شکل زیر، پیام ارائه شده توسط فراخوانی کننده با استفاده از  ``try/catch`` بازیابی می‌شود.



.. note::
    قبلاً یک کلمه کلیدی به نام  ``throw`` با سمنتیک مشابه ``()revert`` وجود داشت که در نسخه 0.4.13 منسوخ شده بود و در نسخه 0.5.0 حذف شد.
    
    There used to be a keyword called ``throw`` with the same semantics as ``revert()`` which
    was deprecated in version 0.4.13 and removed in version 0.5.0.


.. _try-catch:

``try``/``catch``
-----------------

شکست در یک فراخوانی خارجی را می‌توان با استفاده از دستور try/catch به شرح زیر تشخیص داد:



.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.8.1;

    interface DataFeed { function getData(address token) external returns (uint value); }

    contract FeedConsumer {
        DataFeed feed;
        uint errorCount;
        function rate(address token) public returns (uint value, bool success) {
            // Permanently disable the mechanism if there are
            // more than 10 errors.
            require(errorCount < 10);
            try feed.getData(token) returns (uint v) {
                return (v, true);
            } catch Error(string memory /*reason*/) {
                // This is executed in case
                // revert was called inside getData
                // and a reason string was provided.
                errorCount++;
                return (0, false);
            } catch Panic(uint /*errorCode*/) {
                // This is executed in case of a panic,
                // i.e. a serious error like division by zero
                // or overflow. The error code can be used
                // to determine the kind of error.
                errorCount++;
                return (0, false);
            } catch (bytes memory /*lowLevelData*/) {
                // This is executed in case revert() was used.
                errorCount++;
                return (0, false);
            }
        }
    }

کلمه کلیدی  ``try`` باید با عبارتی که یک فراخوانی تابع خارجی یا ایجاد قرارداد را نشان می‌دهد 
(``()new ContractName``) دنبال شود. خطاهای داخل عبارت گرفته نمی‌شوند (برای مثال اگر عبارت 
پیچیده‌ای است که شامل فراخوانی تابع داخلی نیز شود)، فقط یک  revert در داخل خود فراخوان خارجی اتفاق 
می‌افتد. قسمت  ``returns`` (که اختیاری است) که در زیر آمده است متغیرهای  returns را مطابقت 
می‌دهد که با انواع برگشت داده شده توسط فراخوانی خارجی مطابقت دارد. در صورت عدم وجود خطا، این متغیرها 
تعیین می شوند و اجرای قرارداد در اولین بلوک موفقیت ادامه می یابد. اگر بلوک موفقیت به پایان برسد، اجرا 
پس از بلوک های گرفتن ادامه می یابد.


سالیدیتی بسته به نوع خطا از تایپ‌های مختلف بلوک‌های catch پشتیبانی می‌کند:



-	``{ ... }catch Error(string memory reason)`` : این عبارت catch در صورتی اجرا می‌شود که خطا ناشی از  ``revert("reasonString")``  یا ``require(false, "reasonString")``  (یا خطای داخلی که باعث چنین اکسپشنی می‌شود) باشد.
-	``{ ... }catch Panic(uint errorCode)`` : اگر خطا ناشی از panic باشد، یعنی  با شکست  ``assert`` ، تقسیم بر صفر، دسترسی به آرایه نامعتبر، overflow حسابی و موارد دیگر، این عبارت catch اجرا خواهد شد.
-	``{ ... }catch (bytes memory lowLevelData)``: این عبارت در صورتی اجرا می‌شود که خطای امضا  با هیچ عبارت دیگری مطابقت نداشته باشد، در هنگام رمزگشایی پیام خطا خطایی رخ داده باشد یا اگر هیچ داده خطایی به استثنا ارائه نشده باشد. متغیر اعلام شده در این حالت دسترسی به داده های خطای سطح پایین را فراهم می کند.
-	``{ ... }catch``: اگر به داده‌های خطا علاقه‌ای ندارید، می توانید به جای بند قبلی از  catch { ... } (حتی به عنوان تنها بند گرفتن) استفاده کنید.


برنامه ریزی شده است که در آینده از تایپ‌های دیگر خطای داده‌ه نیز پشتیبانی شود. رشته‌های ``Error`` 
و ``Panic`` در حال حاضر به همانطور که هست تجزیه میشوند و با آن‌ها به  عنوان identifiers رفتار نمی‌شوند.


برای گرفتن همه موارد خطا، باید حداقل عبارت ``{ ...}catch``  
یا  ``{ ... }catch (bytes memory lowLevelData)`` داشته باشید.

متغیرهای اعلام شده در  ``returns`` و عبارت  ``catch`` فقط در محدوده بلوکی هستند که دنبال میکنند.


.. note::

    اگر هنگام رمزگشایی داده‌های بازگشتی در یک دستور try/catch خطایی رخ دهد، این امر باعث ایجاد یک 
    اکسپشن در قرارداد در حال اجرا می‌شود و به همین دلیل، در عبارت catch دریافت نمیشود. اگر هنگام 
    رمزگشایی  ``catch Error(string memory reason)`` خطایی رخ دهد و یک عبارت 
    catch سطح پایین وجود داشته باشد، این خطا در آنجا تشخیص داده می‌شود.

    If an error happens during the decoding of the return data
    inside a try/catch-statement, this causes an exception in the currently
    executing contract and because of that, it is not caught in the catch clause.
    If there is an error during decoding of ``catch Error(string memory reason)``
    and there is a low-level catch clause, this error is caught there.

.. note::

    اگر اجرا به یک catch-block برسد، اثرات تغییر state فراخوانی خارجی برگردانده شده است. اگر اجرا به 
    بلوک موفقیت برسد، اثرات برگشت داده نمی‌شوند. اگر اثرات برگردانده شده‌ باشد، اجرا یا در یک بلوک catch 
    ادامه می یابد یا اجرای دستور try/catch به خودی خود revert می‌شود (برای مثال به دلیل شکست در 
    رمزگشایی همانطور که در بالا ذکر شد یا به دلیل عدم ارائه یک عبارت catch سطح پایین).


.. note::

    دلیل یک فراخوانی ناموفق می‌تواند manifold باشد. تصور نکنید که پیام خطا مستقیماً از قرارداد فراخوانی 
    شده می‌آید: ممکن است خطا در اعماق فراخوانی زنجیره رخ داده باشد و قرارداد فراخوانی شده فقط آن را 
    ارسال کرده باشد. همچنین، ممکن است به دلیل وضعیت اتمام گاز (out-of-gas) باشد و نه یک خطای 
    عمدی: فراخوانی کننده همیشه 63/64 گاز را در فراخوانی حفظ می‌کند و بنابراین حتی اگر قرارداد فراخوانی 
    کننده از بین برود، فراخوانی کننده هنوز مقداری گاز باقی مانده دارد.

