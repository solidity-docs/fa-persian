###############################
مقدمه‌ای بر قراد‌های هوشمند 
###############################

.. _simple-smart-contract:

***********************
یک قرارداد هوشمند ساده 
***********************

بیایید با یک مثال ابتدایی شروع کنیم که مقدار یک متغیر را تعیین می‌کند و آن را در معرض دسترسی سایر قراردادها قرار می‌دهد. اینکه الان شما متوجه چیزی نمی‌شوید طبیعی می‌باشد، بعداً به جزئیات بیشتری خواهیم پرداخت.

مثال ذخیره سازی
===============

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.4.16 <0.9.0;

    contract SimpleStorage {
        uint storedData;

        function set(uint x) public {
            storedData = x;
        }

        function get() public view returns (uint) {
            return storedData;
        }
    }

خط اول به شما می‌گوید کد منبع ، تحت مجوز GPL نسخه 3.0 می‌باشد. در جایی که انتشار کد منبع به صورت پیشفرض  باشد، مشخص کننده‌هایِ مجوز قابلِ خواندن توسطِ ماشین  مهم هستند.
خط بعدی مشخص می‌کند کد منبع برای سالیدیتی نسخه 0.4.16 یا نسخه جدیدتر زبان نوشته شده است، اما شامل نسخه 0.9.0 نمی‌باشد. بخاطر اینکه قرارداد هوشمند می‌تواند رفتار متفاوتی داشته ‌باشد، به این هدف که اطمینان حاصل شود قرارداد هوشمند نتواند با نسخه جدید کامپایلر، کامپایل شود. :ref:`پراگما <pragma>` (Pragmas) دستورالعمل‌های رایج برای کامپایلرها در مورد نحوه برخورد با کد منبع می‌باشند (به عنوان مثال  `پراگما یکبار  (pragma once) <https://en.wikipedia.org/wiki/Pragma_once>`_ ). 

قراردادها در سالیدتی به معنای مجموعه‌ای از کد (*توابع* آن‌ها) و داده‌ها (*حالت* آن‌ها) است که در یک آدرس خاص در بلاکچین اتریوم قرار دارند. خط ``;uint storedData``  یک متغیر حالت  به نام ``storedData``  از نوع ``uint``  (عددِ صحیحِ بدونِ علامت  256 بیتی) را مشخص می‌کند. می‌توان آن را به عنوان یک اسلات  در پایگاه داده در نظر بگیرید که می‌توانید با فراخوانی توابع کدی که پایگاه داده را مدیریت می‌کند، آن‌ها را جستوجو کرده و ویرایش کنید. در این مثال، قرارداد توابع  ``set`` و ``get``  را تعریف می‌کند که  برای ویرایش  یا بازیابی  مقدار متغیر استفاده شود.

همانند سایر زبان‌‌های رایج، برای دسترسی به یک متغیر حالت، نیازی به پیشوند ``.this``  ندارید.
 این قرارداد جدا از اینکه هنوز کار زیادی انجام نداده‌است (به دلیل زیرساخت‌های ساخته شده توسط اتریوم) اجازه می‌دهد هر شخص یک عدد را ذخیره کند، که این عدد توسط هر شخصی در دنیا بدون هیچ روش امکان پذیر برای جلوگیری از انتشار آن قابل دسترس می‌باشد. هر شخصی می‌تواند مجدداً تابع ``set``   را فراخوانی کند و عدد را رونویسی کند، اما عدد در تاریخچه‌ِ بلاکچین هنوز ذخیره بماند. بعداً خواهید دید که چگونه می‌توانید محدودیت‌های دسترسی را اعمال کنید تا فقط شما بتوانید عدد را تغییر دهید. 


.. warning::
    در هنگام استفاده از متن Unicode مراقب باشید، زیرا نویسه‌های  مشابه (یا حتی یکسان) می‌توانند دارای نکته‌های کدی  متفاوتی باشند و همینطور به عنوان یک آرایه بایت  متفاوت کدگذاری شوند.

.. note::
    همه شناسه‌ها  (نام قرارداد، نام تابع و نام متغیر) به مجموعه کاراکترهای ASCII محدود می‌‌شوند. ذخیره داده‌های رمزگذاری شده UTF-8 در متغیرهای رشته‌ای  امکان پذیر است.

.. index:: ! subcurrency

مثال  ساب کارنسی یا زیر ارز
===================

قرارداد زیر ساده ترین شکل ارز رمزنگاری شده  را پیاده سازی می‌کند. این قرارداد فقط به سازنده آن اجازه می‌دهد سکه‌ های جدید ایجاد کند (طرح‌های مختلف صدور امکان پذیر است). هر کسی می‌تواند بدون نیاز به ثبت نام با نام کاربری و رمز عبور، سکه برای یکدیگر ارسال کنند، تمام آنچه شما نیاز دارید یک جفت کلید اتریوم است.

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity ^0.8.4;

    contract Coin {
        // The keyword "public" makes variables
        // accessible from other contracts
        address public minter;
        mapping (address => uint) public balances;

        // Events allow clients to react to specific
        // contract changes you declare
        event Sent(address from, address to, uint amount);

        // Constructor code is only run when the contract
        // is created
        constructor() {
            minter = msg.sender;
        }

        // Sends an amount of newly created coins to an address
        // Can only be called by the contract creator
        function mint(address receiver, uint amount) public {
            require(msg.sender == minter);
            balances[receiver] += amount;
        }

        // Errors allow you to provide information about
        // why an operation failed. They are returned
        // to the caller of the function.
        error InsufficientBalance(uint requested, uint available);

        // Sends an amount of existing coins
        // from any caller to an address
        function send(address receiver, uint amount) public {
            if (amount > balances[msg.sender])
                revert InsufficientBalance({
                    requested: amount,
                    available: balances[msg.sender]
                });

            balances[msg.sender] -= amount;
            balances[receiver] += amount;
            emit Sent(msg.sender, receiver, amount);
        }
    }

این قرارداد مفاهیم جدیدی را معرفی می‌کند، اجازه دهید یکی یکی آنها را مرور کنیم.



خط ``;address public minter``  متغیر حالت از نوع  :ref:`address<address>` را مشخص می‌کند. نوع آدرس یک مقدار 160 بیتی است که اجازه هیچ گونه عملیات حسابی را نمی‌دهد. متغییر ``address`` برای ذخیره آدرس‌ قرارداد‌ها یا یک هش از نیمه عمومیِ  یک جفت کلید  متعلق به :ref:`حساب‌های خارجی <accounts>` مناسب است.

کلمه کلیدی ``public`` به طور خودکار تابعی را ایجاد می‌کند که به شما امکان می‌دهد، از خارج از قرارداد به مقدار فعلی متغیر حالت  دسترسی پیدا کنید. بدون این کلمه کلیدی، سایر قراردادها راهی برای دسترسی به متغیر ندارند. کد تابع که توسط کامپایلر تولید می‌شود معادل موارد زیر است (فعلاً از  ``external`` و  ``view`` چشم پوشی کنید):

.. code-block:: solidity

    function minter() external view returns (address) { return minter; }

می‌توانید توابعی مانند موارد فوق را خود اضافه کنید، اما یک متغیرحالت و تابعی با همان نام خواهید داشت. اما نیازی به این کار نیست، کامپایلر آن را برای شما مشخص می‌کند.

.. index:: mapping

خط بعدی، ``;mapping (address => uint) public balances`` یک متغیر ِحالتِ عمومی  ایجاد می‌کند، اما یک نوع داده  پیچیده‌تر است. نوع :ref:`mapping <mapping-types>`  آدرس‌ها را به اعداد صحیح بدون علامت  (:ref:`unsigned integers <integers>`) نگاشت  می‌کند.

Mapping ‌ها را می‌توان به عنوان `جداول هش  <https://en.wikipedia.org/wiki/Hash_table>`_ مشاهده کرد که عملاً مقداردهی اولیه شده‌اند، به طوری که همه کلیدهای ممکن از همان ابتدا وجود داشته و به مقداری که همهِ نمایشِ بایت  آن‌ها صفر است نگاشت شده باشند. با این حال، نه می‌توان لیستی از تمام کلیدهای Mapping و نه لیستی از تمام مقادیر را بدست آورد. آنچه را که به Mapping اضافه کرده‌اید، ثبت کنید یا از آن در زمینه‌ای که نیازی به آن مقدار نیست استفاده کنید. یا حتی بهتر است که یک لیست نگهدارید یا از نوع داده  مناسب استفاده کنید.

:ref:`تابع getter <getter-functions>`  ایجاد شده توسط کلمه کلیدی ``public``  در Mapping پیچیده‌تر است. به شرح زیر است:

.. code-block:: solidity

    function balances(address _account) external view returns (uint) {
        return balances[_account];
    }

شما می‌توانید برای جستجوی بالانس  یک حساب از این تابع استفاده کنید.

.. index:: event

خط ``;event Sent(address from, address to, uint amount)`` یک :ref:`"event" <events>`  را مشخص می‌کند که در آخرین خط با تابع ``send``  منتشر می‌شود. کلاینت اتریوم مانند برنامه‌های کاربردی  وب می‌توانند به این رویداد ها که در بلاکچین منتشر شده‌اند، بدون هزینه زیاد گوش دهند. شنونده به محض انتشار، آرگومان‌های ``from`` ، ``to`` و ``amount`` را دریافت می‌کند، که امکان ردیابی تراکنش‌ها را فراهم می‌کند.

برای گوش دادن به این event، می‌توانید از کد جاوا اسکریپت زیر استفاده کنید که از `web3.js <https://github.com/ethereum/web3.js/>`_  برای ایجاد شیء قرارداد ``Coin``   استفاده می‌کند و هر رابط کاربری تابع ``balances``   که به صورت خودکار ایجاد شده را از بالا فراخوانی می‌کند::

    Coin.Sent().watch({}, '', function(error, result) {
        if (!error) {
            console.log("Coin transfer: " + result.args.amount +
                " coins were sent from " + result.args.from +
                " to " + result.args.to + ".");
            console.log("Balances now:\n" +
                "Sender: " + Coin.balances.call(result.args.from) +
                "Receiver: " + Coin.balances.call(result.args.to));
        }
    })

.. index:: coin

:ref:`constructor<constructor>`  یک تابع خاص است که در هنگام ایجاد قرارداد اجرا می‌شود و پس از آن نمی‌توان آن را فراخوانی کرد. در این مورد، constructor آدرس شخص ایجاد کننده قرارداد را برای همیشه ذخیره می‌کند. متغیر ``msg``   (همراه با  ``tx`` و  ``block``) یک :ref:`متغیر جهانی خاص  <special-variables-functions>`   که شامل خصوصیاتی می‌باشد و امکان دسترسی به بلاکچین را فراهم می‌کند. ``msg.sender``  همیشه آدرسی است که فراخوانی تابع فعلی (خارجی ) از آن گرفته شده‌است.

توابعی که قرارداد را تشکیل می‌دهند و کاربران و قراردادها می‌توانند آنها را فراخوانی کنند، ``mint`` و ``send``   هستند.

The ``mint`` function sends an amount of newly created coins to another address. The :ref:`require
<assert-and-require>` function call defines conditions that reverts all changes if not met. In this
example, ``require(msg.sender == minter);`` ensures that only the creator of the contract can call
``mint``. In general, the creator can mint as many tokens as they like, but at some point, this will
lead to a phenomenon called "overflow". Note that because of the default :ref:`Checked arithmetic
<unchecked>`, the transaction would revert if the expression ``balances[receiver] += amount;``
overflows, i.e., when ``balances[receiver] + amount`` in arbitrary precision arithmetic is larger
than the maximum value of ``uint`` (``2**256 - 1``). This is also true for the statement
``balances[receiver] += amount;`` in the function ``send``.


:ref:`خطاها <errors>`  به شما امکان می‌دهند اطلاعات بیشتری در مورد علت شرایط یا شکست عملیات به فراخوانی کننده  ارائه دهید. خطاها همراه با  :ref:`دستورات revert <revert-statement>`   استفاده می‌شوند. دستورات revert بدون تغییر و بدون قید و شرط، تمام تغییرات مشابه با تابع ``require``  را نابود و برمی‌گردانند ، اما همچنین به شما امکان ارائه نام خطا و داده‌های اضافی را که به فراخوانی کننده (و در نهایت به برنامه سمت کاربر  یا جستوجوگر بلاک ) نشان دهید، را می‌دهند. به طوری که یک شکست  را می‌توان به راحتی عیب یابی  کرد یا به آن واکنش نشان داد.


The ``send`` function can be used by anyone (who already
has some of these coins) to send coins to anyone else. If the sender does not have
enough coins to send, the ``if`` condition evaluates to true. As a result, the ``revert`` will cause the operation to fail
while providing the sender with error details using the ``InsufficientBalance`` error.

.. note::
   اگر از این قرارداد برای ارسال سکه به یک آدرس استفاده کنید، وقتی به آن آدرس در یک مرورگر بلاکچین نگاه کنید، چیزی مشاهده نخواهید کرد. زیرا تاریخچه ارسال سکه و بالانس تغییر یافته و فقط در فضای ذخیره سازی داده  این قراردادِ خاصِ سکه ذخیره می‌شود. با استفاده از رویداد ها، می‌توانید یک "جستجوگر بلاکچینی" ایجاد کنید که تراکنش‌ها و بالانس‌های سکه جدید شما را ردیابی می‌کند، اما باید آدرس قرارداد سکه و نه آدرس صاحبان سکه را بررسی کنید.

.. _blockchain-basics:

*****************
مبانی بلاکچین
*****************
درک بلاکچین به عنوان یک مفهوم برای برنامه نویسان خیلی دشوار نمی‌باشد. به این دلیل که بیشتر پیچیدگی در مفهوم (استخراج ، `هش کردن <https://en.wikipedia.org/wiki/Cryptographic_hash_function>`_ ، `رمزنگاری منحنی بیضوی <https://en.wikipedia.org/wiki/Elliptic_curve_cryptography>`_  ، `شبکه‌های همتا به همتا <https://en.wikipedia.org/wiki/Peer-to-peer>`_  و غیره) می‌باشد که فقط برای ارائه مجموعه خاصی از ویژگی‌ها و وعده‌ها برای پلتفرم می‌باشد. پس از پذیرش این ویژگی‌ها، دیگر لازم نیست نگران فناوری زیر ساخت باشید - یا برای استفاده از آن باید بدانید که AWS آمازون چگونه کار می‌کند؟

.. index:: transaction

تراکنش‌ها 
============

بلاکچین یک پایگاه داده تراکنشی  مشترک جهانی  است. این بدان معناست که هر کس فقط با شرکت در شبکه می‌تواند ورودی‌های پایگاه داده را بخواند. اگر می‌خواهید چیزی را در پایگاه داده تغییر دهید، باید به اصطلاح، تراکنش ایجاد کنید، باید توسط دیگران پذیرفته شود. کلمه تراکنش به تغییری که می‌خواهید ایجاد کنید که یا اصلاً انجام نشده یا کاملاً اعمال شده اشاره دارد (فرض کنید می‌خواهید همزمان دو مقدار را تغییر دهید). علاوه بر این، زمانی که تراکنش شما در پایگاه داده اعمال می‌شود، هیچ تراکنش دیگری نمی‌تواند آن را تغییر دهد.

به عنوان مثال، جدولی را تصور کنید که بالانس تمام حساب‌ها را در یک ارز الکترونیکی  فهرست می‌کند. اگر انتقال از یک حساب به حساب دیگر درخواست شود، ماهیت تراکنشی پایگاه داده تضمین می‌کند که اگر مبلغ از یک حساب کم شود، همیشه به حساب دیگر اضافه می‌شود. اگر به هر دلیلی، افزودن مبلغ به حساب مقصد  امکان پذیر نباشد، حساب مبدأ  نیز ویرایش نمی‌شود.

علاوه بر این، یک تراکنش همیشه به صورت رمزنگاری توسط فرستنده (سازنده ) امضا می‌شود. این امر باعث می‌شود محافظت از دسترسی به تغییرات خاص پایگاه داده آسان باشد. در مثال ارز الکترونیکی ، یک بررسی ساده تضمین می‌کند که فقط شخصی که کلیدهای حساب را دارد می‌تواند از آن پول انتقال بدهد.

.. index:: ! block

بلاک‌ها  
======

یک مانع عمده برای غلبه بر چیزی که (در اصطلاحات بیتکوین) "حمله دو بار خرج کردن  " نامیده می‌شود : اگر دو تراکنش در شبکه وجود داشته باشد که هر دو بخواهند یک حساب را خالی کنند چه اتفاقی می‌افتد؟ فقط یکی از تراکنش‌ها می‌تواند معتبر باشد، به طور معمول تراکنشی که ابتدا پذیرفته می‌شود. مسئله این است که "First" یک اصطلاح  عَملی در یک شبکه همتا به همتا  نیست.

پاسخ خلاصه این است که شما نیاز ندارید مراقبت باشید. یک ترتیب از تراکنش‌های پذیرفته شده به صورت جهانی برای شما انتخاب می‌شود، که اختلافات را حل می‌کند. تراکنش‌ها به صورت چیزی که "بلاک" نام دارد، بسته و سپس اجرا می‌شوند و در بین گره‌های مشارکت کننده توزیع می‌شوند. اگر دو تراکنش با یکدیگر مغایرت داشته باشند، تراکنشی که در نهایت دوم شود رد می‌شود و بخشی از بلاک نمی‌شود.

این بلاک‌ها از نظر زمانی یک توالی خطی  را تشکیل می‌دهند و بخاطر همین است که کلمه "بلاکچین" از آن گرفته می‌شود. بلاک‌ها در فواصل نسبتاً منظمی به زنجیره اضافه می‌شوند - برای اتریوم تقریباً هر 17 ثانیه می‌باشد.

به عنوان بخشی از "مکانیزم انتخاب ترتیبی  " (که "استخراج " نامیده می‌شود) ممکن است فقط در "نوک " زنجیره، برگرداندن بلاک‌ها هرزگاهی اتفاق بیفتد. هرچه تعداد بلاک‌های اضافه شده در بالای یک بلاکِ خاص بیشتر باشد، احتمال برگردانندن آن بلاک کمتر است. بنابراین ممکن است تراکنش شما برگردانده شود و حتی از بلاکچین حذف شود، اما هرچه بیشتر منتظر بمانید، احتمال آن کمتر است.

.. note::
    تضمین نمی‌شود که تراکنش در بلاک بعدی یا هر بلاک مشخص خاص در آینده لحاظ شود، زیرا این کار به عهده ارسال کننده نمی‌باشد، بلکه ماینرها باید تعیین کنند که تراکنش در کدام بلاک لحاظ شود. 

    اگر می‌خواهید فراخوانی قراردادتان را در آینده زمان بندی کنید، می توانید از `alarm clock <https://www.ethereum-alarm-clock.com/>`_  یا سرویس اوراکل مشابه استفاده کنید.


.. _the-ethereum-virtual-machine:

.. index:: !evm, ! ethereum virtual machine

****************************
ماشین مجازی اتریوم 
****************************

مرور کلی
========

ماشین مجازی اتریوم  یا EVM محیط زمان اجرای قراردادهای هوشمند در اتریوم می‌باشد. EVM نه تنها یک جعبه است بلکه در واقع کاملاً ایزوله شده است، به این معنی که کدی که در داخل EVM اجرا می شود، به شبکه و فایل سیستم  یا سایر فرآیندها دسترسی ندارد. در قراردادهای هوشمند حتی دسترسی به سایر قراردادهای هوشمند محدود است.

.. index:: ! account, address, storage, balance

.. _accounts:

حساب‌ها
========

در اتریوم دو نوع حساب وجود دارد که فضای آدرس یکسانی را به اشتراک می‌گذارند: **حساب های خارجی**  که توسط جفت کلید عمومی-خصوصی  (به عنوان مثال انسان) کنترل می‌شوند و **حساب‌های قراردادی**  که توسط کدی که همراه با حساب ذخیره می‌شود کنترل می‌شوند.

آدرس یک حساب خارجی  از کلید عمومی مشخص می‌شود در حالی که آدرس قرارداد در زمان ایجاد قرارداد مشخص می‌شود (از آدرس سازنده و تعداد تراکنش‌های ارسال شده از آن آدرس مشتق گرفته شده است، که  به اصطلاح " نانس " نامیده می‌شود).

صرف نظر از اینکه حساب، کد را ذخیره می‌کند یا نه، EVM با این دو نوع حساب به صورت برابر رفتار می‌کند.

هر حساب دارای یک حافظه کلید-مقدار  ثابت است که کلمات 256 بیتی را با کلمات 256 بیتی که  **storage** نامیده می‌شود.

علاوه بر این، هر حساب **بالانسی** معادل به اتر دارد (به طور دقیق در wei  ، ``1 ether``  معادل ``10**18 wei``  است) که می‌تواند با ارسال تراکنش‌هایی که شامل اتر هستند، اصلاح شود.

.. index:: ! transaction

تراکنش‌ها 
============

تراکنش پیامی است که از یک حساب به حساب دیگر ارسال می‌شود (که ممکن است یکسان یا خالی باشد، به مطالب زیر مراجعه کنید). تراکنش‌ها می‌تواند شامل داده‌های باینری (که "پیلود " نامیده می‌شود) و اتر باشند.

اگر حساب مقصد حاوی کد باشد، آن کد اجرا می شود و پیلود به عنوان داده ورودی ارائه می‌شود.

اگر حساب مقصد  تنظیم نشده باشد ( یعنی تراکنش گیرنده نداشته باشد یا  ``null``تنظیم شده‌ باشد)، تراکنش **قرارداد جدید** ایجاد می‌کند. همانطور که قبلاً ذکر شد، آدرس آن قرارداد آدرس صفر  نمی‌باشد، بلکه آدرسی است که از فرستنده و تعداد تراکنش‌های ارسال شده آن ("نانس") گرفته شده است. پیلود چنین تراکنش ایجاد قرارداد به عنوان بایت کد  EVM در نظر گرفته شده و اجرا می‌شود. داده‌های خروجی این اجرا به عنوان کدِ قرارداد برای همیشه ذخیره می‌شود. این بدان معناست که برای ایجاد قرارداد، شما کد واقعی قرارداد را ارسال نمی‌کنید، بلکه در واقع کدی که هنگام اجرا، آن کد را برمی‌گرداند .

.. note::
  هنگامی که یک قرارداد در حال ایجاد باشد، کد آن هنوز خالی است. به همین دلیل، تا زمانی که سازنده آن، اجرای آن را به اتمام نرسانده، نباید مجدداً قرارداد در حال ساخت را فراخونی مجدد کنید.

.. index:: ! gas, ! gas price

گَس
===

به محض ایجاد، هر تراکنش با مقدار مشخصی **گَس** شارژ می شود، هدف آن محدود کردن میزان کار مورد نیاز برای انجام تراکنش و پرداخت همزمان هزینه این اجرا است. هنگامی که EVM تراکنش را انجام می‌دهد، گَس طبق قوانین خاص به تدریج خالی می‌شود.

**gas price** مقداری است که توسط سازنده تراکنش تنظیم می‌شود و باید  ``gas_price * gas`` را قبل از حساب ارسالی پرداخت کند. اگر پس از اجرا مقداری گَس باقی مانده باشد، به همان روش به سازنده بازپرداخت می‌شود.

اگر گَس در هر نقطه مصرف شود (یعنی منفی باشد)، یک استثناء اتمام گَس ایجاد می‌شود، که تمام تغییرات و اصلاحات ایجاد شده در حالت  را در این چارچوب فراخوانی فعلی، باز می‌گرداند .

.. index:: ! storage, ! memory, ! stack

فضای ذخیره سازی  ، حافظه مِمُوری  و پشته
=============================

ماشین مجازی اتریوم دارای سه فضا برای ذخیره سازی داده می‌باشد: فضای ذخیره سازی یا storage، حافظه موقت یا مِمُوری و پشته، که در پاراگراف‌های زیر توضیح داده شده‌اند.

هر حساب دارای یک فضای داده به نام **storage** می‌باشد، که بین تابع فراخوانی و تراکنش‌ها ثابت است.

storage یک حافظه کلید_مقدار  می‌باشد که کلمات 256 بیتی را با کلمات 256 بیتی نگاشت  می‌کند. محاسبه storage از طریق قرارداد امکان پذیر نیست، خواندن آن نسبتاً پر هزینه است و برای مقدار دهی و ویرایش کردن پر هزینه‌تر هم می‌باشد. به دلیل این هزینه‌ها، شما باید آنچه را که در storage ذخیره می‌کنید، به میزانِ نیازِ قرارداد برای انجام این کار به حداقل برسانید. . داده‌هایی مانند محاسبه مشتق، کش کردن  و جمع آوری داده‌‌های خارج از قرارداد، را در آن ذخیره کنید. یک قرارداد نمی‌تواند در هر storage ای به جز storage خودش بنویسد یا بخواند.

دومین فضای داده **مِمُوری**  نامیده می‌شود، که هر قرارداد یک نمونهِ پاکِ تازه برای هر فراخونی پیام بدست می‌آورد. مِمُوری خطی است و می‌توان آن را در سطح بایت آدرس دهی کرد، اما خواندن مِمُوری به عرض 256 بیت محدود می‌شود، در هنگام نوشتن می‌تواند 8 بیت یا 256 بیت عرض داشته باشد. هنگام دسترسی (خواندن یا نوشتن) به یک کلمه مِمُوری که قبلا دست نخورده است (یعنی هر آفست  درون یک کلمه)، مِمُوری با یک کلمه (256 بیتی) گسترش می‌یابد. در زمان گسترش، هزینه گَس باید پرداخت شود. حافظه هرچه بزرگتر شود گرانتر است (هزینه گَس به صورت درجه دو اندازه گیری می‌شود).

EVM یک ماشین ثبت نیست بلکه یک ماشین پشته است، بنابراین تمام محاسبات در یک فضای داده به نام **پشته** انجام می‌شود. حداکثر اندازه آن 1024 عنصر است و شامل کلمات 256 بیتی است. دسترسی به پشته به روش "بالا انتها" که در زیر توضیح داده شده‌است، محدود می‌باشد: 
امکان کپی کردن یکی از 16 عنصر بالاتر در بالای پشته یا تعویض بالاترین عنصر با یکی از 16 عنصر زیر آن وجود دارد. تمام عملیات دیگر دو عنصر بالاتر (یا یک یا بیشتر، بسته به عملیات) را از پشته گرفته و نتیجه را در پشته درج میکنند. مطمئناً امکان دسترسی عناصر پشته به storage یا مِمُوری برای دستیابی عمیق تر به پشته وجود دارد، اما دسترسی به عناصر دلخواه در اعماق پشته بدون برداشتن قسمت بالای پشته امکان پذیر نیست.


.. index:: ! instruction

مجموعه دستورالعمل‌ها
===============

بیتی یا برشی از مِمُوری  (یا سایر آرایه‌های بایت ) کار می‌کنند. عملیات حسابی ، بیتی ، منطقی  و مقایسه‌ای   معمول وجود دارد. پرش‌های شرطی و غیر شرطی  امکان پذیر است. علاوه بر این، قراردادها می‌توانند به ویژگی‌های مربوط به بلاک فعلی مانند شماره  و برچسب زمان  آن دسترسی داشته باشند. 

برای لیست کامل، لطفاً به :ref:`لیست آپکد <opcodes>`   به عنوان بخشی از مستند اسمبلی داخلی  مراجعه کنید.


.. index:: ! message call, function;call

پیام های فراخوانی 
=============

قراردادها می‌توانند سایر قراردادها را فراخوانی کنند یا اتر را از طریق پیام‌های فراخوانی به حساب‌های غیر قراردادی بفرستند. پیام‌های فراخوانی مانند تراکنش‌ها هستند، بدین معنی که دارای منبع ، مقصد ، پیلود داده ، اتر ، گَس  و داده‌های برگشتی هستند. در واقع، هر تراکنش از یک پیام فراخوانی سطح بالا  تشکیل شده است که به نوبه خود می‌تواند پیام‌های فراخوانی دیگری ایجاد کند.

  یک قرارداد می‌تواند تصمیم بگیرد که چه مقدار از **گَس** باقیمانده آن باید با پیام فراخوانی داخلی ارسال شود و چه مقدار آن را می‌خواهد نگهداری کند. اگر یک استثنای اتمام-گَس  در فراخوانی داخلی (یا هر استثناء دیگر) اتفاق بیفتد، با یک مقدار خطا روی پشته  نشان داده می‌شود. در این حالت، فقط گَس ارسالی همراه با فراخوانی مصرف می‌شود. در سالیدیتی، فراخوانی قرارداد به طور پیش فرض در چنین شرایطی باعث یک استثناء دستی می‌شود، به طوری که استثناء فراخوانی، پشته را به صورت " پنجره نمایش " نمایش می‌دهد.

همانطور که قبلاً گفته شد، قرارداد فراخوانی شده (که می‌تواند همان فراخوانی کننده باشد) یک مِمُوری تازه پاک شده را دریافت می‌کند و به فراخوانی پیلود  دسترسی دارد- که در یک فضای جداگانه به نام فراخوانی داده یا **calldata** ارائه می‌شود. پس از پایان اجرا، داده‌هایی را که در مکانی از مِمُوری فراخوانی کننده که از قبل توسط فراخوانی کننده اختصاص داده شده‌است و در آن ذخیره خواهند شد، را می‌تواند برگرداند. همه‌ی این تماس‌ها کاملاً همگام هستند.

فراخوانی‌ها به عمق 1024 **محدود می‌‌شوند**، این بدان معنی است که برای انجام عملیات پیچیده‌تر، حلقه‌ها  بر فراخوانی‌های مکرر باید ترجیح داده شوند. بعلاوه، فقط 63/64امین از گَس می‌تواند در یک پیام فراخوانی فوروارد شود، که در عمل باعث ایجاد عمق کمتر از 1000 می‌شود.

.. index:: delegatecall, callcode, library

Delegatecall / Callcode و کتابخانه ها
=====================================

نوع خاصی از پیام های فراخوانی به نام ** **delegatecall وجود دارد، که همانند یک پیام فراخوانی می‌باشند، جدا از این واقعیت که کد در آدرس مقصد در قرارداد فراخوانی کننده  اجرا می‌شود و ``msg.sender`` و ``msg.value``  مقادیر خود را تغییر نمی‌دهند.

این بدان معناست که یک قرارداد می‌تواند به صورت پویا در زمان اجرا، کد را از آدرس دیگری بارگیری کند. Storage، آدرس فعلی و بالانس هنوز به قرارداد فراخوانی کننده اشاره دارد و فقط کد از آدرس فراخوانی شده گرفته شده‌است.

delegatecall امکان ویژگی "کتابخانه" در سالیدیتی را فراهم می‌کند: کد کتابخانه قابل استفاده مجدد می‌باشد که می‌تواند در storage قرارداد اعمال شود. به عنوان مثال به منظور پیاده سازی یک ساختار داده پیچیده .

.. index:: log

گزارش‌ها 
====

  می‌توان داده‌ها را در یک ساختار داده‌ای با نمایه خاص ذخیره کرد که همه راه‌ها تا سطح بلاک را نشان می‌دهد. این ویژگی **لاگ یا گزارش** نامیده شده‌است که توسط سالیدیتی به منظور اجرای :ref:`رویداد‌ها <events>` استفاده می‌شود. قراردادها پس از ایجاد نمی‌توانند به لاگ داده‌ها دسترسی داشته باشند، اما از خارج از بلاکچین می‌توان به صورت کارآمد به آنها دسترسی داشته باشند. از آنجا که بخشی از لاگ داده‌ها در `فیلتر‌های بلوم <https://en.wikipedia.org/wiki/Bloom_filter>`_  ذخیره می‌شوند، جستجوی این داده‌ها به روشی کارآمد و رمزنگاری شده امکان پذیر‌است، بنابراین جفت‌های شبکه‌ای که کل بلاکچین را بارگیری نمی‌کنند (به اصطلاح "کلاینت لایت") هنوز هم می‌توانند این لاگ‌ها را پیدا کنید.
.. index:: contract creation

ايجاد كردن
======

قراردادها حتی می‌توانند قراردادهای دیگری را با استفاده از یک آپکد خاص  ایجاد کنند (یعنی آدرس صفر  را به عنوان یک تراکنش به سادگی صدا نمی‌زنند). تنها تفاوت بین **فراخوانی‌های ایجاد**  و پیام‌های فراخوانی عادی  این است که داده‌های پیلود  اجرا می‌شوند و نتیجه به عنوان کد  و فراخوانی کننده ، ذخیره می‌شود. ایجاد کننده، آدرس قرارداد جدید را روی پشته  دریافت می‌کند.

.. index:: selfdestruct, self-destruct, deactivate

غیرفعال کردن و خود تخریبی
============================

تنها راه حذف کد از بلاکچین زمانی است که قراردادی در آن آدرس عملیات  ``selfdestruct``  را انجام دهد. باقی مانده اتر ذخیره شده در آن آدرس به مقصد تعیین شده ارسال می‌شود و سپس storage و کد از حالت  خارج می‌شود. حذف قرارداد از نظر تئوری یک ایده خوب به نظر می‌رسد، اما به طور بالقوه خطرناک است، زیرا اگر کسی اتر را به قراردادهای حذف شده بفرستد، اتر برای همیشه از بین می‌رود.

.. warning::
   حتی اگر قراردادی با  ``selfdestruct``  حذف شود، هنوز به عنوان بخشی از تاریخچهِ بلاکچین باقی می‌ماند و احتمالاً توسط اکثر گره‌های اتریوم نگهداری شود. بنابراین استفاده از ``selfdestruct``  با حذف داده‌ها از روی هارد دیسک یکسان نیست.

.. note::
   حتی اگر کد قرارداد فاقد فراخوانی  ``selfdestruct`` باشد، باز هم می‌تواند آن عملیات را با استفاده از  ``delegatecall``  یا  ``callcode`` انجام دهد.

اگر می‌خواهید قراردادهای خود را غیرفعال  کنید، در عوض باید آنها را با تغییر حالت داخلی  که باعث برگشت همه توابع می‌شود، **غیرفعال** کنید. این امر استفاده از قرارداد را غیرممکن می‌کند، زیرا بلافاصله اتر را برمی‌گرداند.
