.. index:: ! event

.. _events:

*********
رویدادها 
*********

رویداد های سالیدیتی یک خلاصه ای از عملکرد گزارش گیری EVM ارائه می دهند. برنامه ها می
توانند ار طریق رابط RPC به این رویداد ها ثبت نام کنند و به رویداد ها گوش دهند.

رویدادها اعضای وراثتی قرارداد ها هستند. وقتی آنها را فراخوانی می کنید، آنها باعث می شوند
که ورودی هایی که در تراکنش ها ذخیره شده اند گزارش شوند – یک ساختار داده ویژه در
بلاکچین. این گزارش ها با آدرس قرارد داد ها مرتبط هستند، تا زمانی که یک بلوک قابل
دسترس است ، در بلاکچین گنجانده شده اند(از حالا تا بی نهایت،  ممکن است با آرامش نیز
تغییر کند)،. گزارش و رویدادهای آن از داخل قرارداد ها (حتی از قراردادهایی که آنها را ایجاد
کرده اند) قابل دسترس نیست .

یک در خواست Merkle proof  برای گزارش ها امکانپذیر است انجام شود، بنابراین اگر یک
موجودیت خارجی قراردادی به همراه چنین اثباتی ارائه دهد، می تواند بررسی کند که گزارش
واقعا در داخل بلاکچین وجود دارد یا نه. شما باید هدر های بلاک را تهیه کنید زیرا فقط آخرین
256 بلوک هش قابل مشاهده است.

شما می توانید خصیصه ``indexed`` تا حداکثر 3 ورودی اضافه کنید که آن را در یک سختار داده
خاصی بنام "عناوین" :ref:`"topics" <abi_events>` بجای بخش داده ای گزارش قرار می دهد. اگر شما از آرایه های :ref:`reference type
<reference-types>` 
استفاده کنید(شامل رشته ای و بایتی) بعنوان ورودی شاخص دار شده، از هش Keccak-256
به عنوان "عناوین" استفاده و ذخیره می شود، زیرا بخش عناوین تنها می تواند یک کلمه در خود
جای دهد(32 بایت).

تمامی پارامترها/ورودی ها بدون خصیصه ``indexed`` در بخش داده گزارش به روش
:ref:`ABI-encoded <ABI>` کد گذاری می شوند.

عناوین شما را قادر می شازند تا بین رویداد ها جستجو کنید، برای مثال زمانی که می خواهید
یک ترتیب بلوک از رویدادهای خاص را فیلتر کنید. شما همچنین می توانید رویدادها را بر اساس
آدرس قراردادی که رویداد را منتشر کرده است ، فیلتر کنید.

برای مثال ، کد زیر در web3.js از `method <https://web3js.readthedocs.io/en/1.0/web3-eth-subscribe.html#subscribe-logs>`_ ``subscribe("logs")`` جهت فیلتر گزارش هایی که
با عنوانی با مقدار آدرس مشخص دارند، استفاده می کند:

.. code-block:: javascript

    var options = {
        fromBlock: 0,
        address: web3.eth.defaultAccount,
        topics: ["0x0000000000000000000000000000000000000000000000000000000000000000", null, null]
    };
    web3.eth.subscribe('logs', options, function (error, result) {
        if (!error)
            console.log(result);
    })
        .on("data", function (log) {
            console.log(log);
        })
        .on("changed", function (log) {
    });


یکی از عناوین امضای هش رویداد است، مگر شما رویداد را به صورت ``ناشناس`` تعریف کرده
باشید. این بدان معناست که امکان فیلتر رویدادهایی با نام ناشناس وجود ندارد، شما تنها می
توانید رویداد ها را توسط آدرس قرارداد فیلتر کنید. مزیت رویداد های نا شناس این است که
استقرار و فراخوانی آنها ارزان است.

.. note::
    Since the transaction log only stores the event data and not the type,
    you have to know the type of the event, including which parameter is
    indexed and if the event is anonymous in order to correctly interpret
    the data.
    In particular, it is possible to "fake" the signature of another event
    using an anonymous event.

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.4.21 <0.9.0;

    contract ClientReceipt {
        event Deposit(
            address indexed _from,
            bytes32 indexed _id,
            uint _value
        );

        function deposit(bytes32 _id) public payable {
            // Events are emitted using `emit`, followed by
            // the name of the event and the arguments
            // (if any) in parentheses. Any such invocation
            // (even deeply nested) can be detected from
            // the JavaScript API by filtering for `Deposit`.
            emit Deposit(msg.sender, _id, msg.value);
        }
    }

استفاده در جاوا اسکریپ API  به شکل زیر است:

.. code-block:: javascript

    var abi = /* abi as generated by the compiler */;
    var ClientReceipt = web3.eth.contract(abi);
    var clientReceipt = ClientReceipt.at("0x1234...ab67" /* address */);

    var depositEvent = clientReceipt.Deposit();

    // watch for changes
    depositEvent.watch(function(error, result){
        // result contains non-indexed arguments and topics
        // given to the `Deposit` call.
        if (!error)
            console.log(result);
    });


    // Or pass a callback to start watching immediately
    var depositEvent = clientReceipt.Deposit(function(error, result) {
        if (!error)
            console.log(result);
    });

خروجی بالا شبیه زیر است (کوتاه شده است):

.. code-block:: json

    {
       "returnValues": {
           "_from": "0x1111…FFFFCCCC",
           "_id": "0x50…sd5adb20",
           "_value": "0x420042"
       },
       "raw": {
           "data": "0x7f…91385",
           "topics": ["0xfd4…b4ead7", "0x7f…1a91385"]
       }
    }

منابع اضافی برای درک رویداد ها 
==============================================

- `اسناد جاوا اسکریپت <https://github.com/ethereum/web3.js/blob/1.x/docs/web3-eth-contract.rst#events>`_
- `نمونه های استفاده از رویدادها <https://github.com/ethchange/smart-exchange/blob/master/lib/contracts/SmartExchange.sol>`_
- `چگونگی دسترسی به آنها در جاوا اسکریپت <https://github.com/ethchange/smart-exchange/blob/master/lib/exchange_transactions.js>`_
