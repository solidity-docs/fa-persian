.. index:: assignment, ! delete, lvalue

اپراتورهای شامل  LValues
===========================
اگر  ``a`` یک LValue باشد (به عنوان مثال یک متغیر یا چیزی که می‌توان به آن اختصاص داد)، عملگرهای زیر به صورت مختصر در دسترس هستند:

``a += e``  معادل  ``a = a + e`` است. عملگرها  ``=-`` ، ``=*`` ، ``=/`` ، ``%=`` ، ``=|`` ، ``=&``  و ``=^``  بر این 
اساس تعریف می‌شوند.  ``++a`` و  ``--a`` معادل  ``a += 1`` / ``a -= 1``  هستند اما این عبارت هنوز مقدار 
قبلی  ``a`` را دارد. در مقابل ،  ``a--`` و  ``a++`` تأثیر یکسانی در  ``a`` دارند اما مقدار را پس از تغییر برمی‌گردانند.


.. _delete:

حذف 
------

``delete a`` یک مقدار اولیه را برای نوع، به  ``a`` اختصاص می‌دهد. یعنی برای اعداد صحیح معادل  ``a = 0``
است، اما همچنین می‌تواند در آرایه ها مورد استفاده قرار گیرد، جایی که یک آرایه پویا از طول صفر یا یک آرایه 
ایستا با همان طول را با تمام عناصر تنظیم شده روی مقدار اولیه خود اختصاص 
می‌دهد.  ``delete a[x]`` مورد را در شاخص  ``x`` آرایه حذف می‌کند و سایر عناصر و طول آرایه را دست 
نخورده باقی می‌گذارد. این کار به طور ویژه به این معنی است که در آرایه شکاف ایجاد می‌کند. اگر قصد حذف 
موارد را دارید، :ref:`mapping <mapping-types>` احتمالاً انتخاب بهتری است.

برای structها، یک struct را با تنظیم مجدد همه اعضا اختصاص می‌دهد. به عبارت دیگر، مقدار ``a``  پس از 
``delete a``  همانی است که اگر ``a``  بدون انتساب اعلام شود، با توجه به هشدار زیر:


``delete``  تأثیری در نگاشت ندارد (زیرا ممکن است کلیدهای نگاشت دلخواه باشند و به طور کلی ناشناخته باشند). 
بنابراین اگر یک struct را حذف کنید، همه اعضا را که نگاشت نباشند مجدد تنظیم می‌کند و همچنین 
به عضوها بازگشت می‌یابد مگر اینکه آنها نگاشت باشند. با این حال، کلیدهای جداگانه و به آنچه نگاشت می‌شوند 
می‌توانند حذف شوند: اگر ``a``  نگاشت باشد، سپس  ``delete a[x]`` مقدار ذخیره شده در  ``x`` را حذف خواهد کرد.


توجه به این نکته مهم است که ``delete a``  واقعاً مانند انتساب به ``a``  رفتار می‌کند، یعنی یک شی جدید 
را در  ``a``  ذخیره می‌کند. این تمایز زمانی قابل مشاهده‌است که ``a``  متغیر مرجع باشد: فقط یک  aرا خود 
مجدد تنظیم می‌کند نه مقداری که قبلاً به آن اشاره کرده بود.



.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.4.0 <0.9.0;

    contract DeleteExample {
        uint data;
        uint[] dataArray;

        function f() public {
            uint x = data;
            delete x; // sets x to 0, does not affect data
            delete data; // sets data to 0, does not affect x
            uint[] storage y = dataArray;
            delete dataArray; // this sets dataArray.length to zero, but as uint[] is a complex object, also
            // y is affected which is an alias to the storage object
            // On the other hand: "delete y" is not valid, as assignments to local variables
            // referencing storage objects can only be made from existing storage objects.
            assert(y.length == 0);
        }
    }
