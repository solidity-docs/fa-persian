.. index:: ! type;conversion, ! cast

.. _types-conversion-elementary-types:

تبدیل بین نوع‌های اصلی (Conversions between Elementary Types)
====================================

تبدیل‌های ضمنی (Implicit Conversions)
--------------------

در برخی موارد هنگام انتساب‌ها، هنگام انتقال آرگومان‌ها به توابع و هنگام اعمال عملگرها، کامپایلر به طور خودکار 
یک نوع تبدیل ضمنی اعمال می‌کند. به طور کلی، اگر به صورت سمنتیک معنا پیدا کند و هیچ اطلاعاتی از بین 
نرود، تبدیل ضمنی بین مقدار_نوع‌های مختلف امکان پذیر است.


به عنوان مثال،  ``uint8`` به  ``uint16`` و  ``int128`` به  ``int256`` قابل تبدیل است، 
اما  ``int8`` به  ``uint256`` قابل تبدیل نیست، زیرا  ``uint256`` نمی‌تواند مقادیری مانند  ``1-`` را نگه دارد.

For example, ``uint8`` is convertible to
``uint16`` and ``int128`` to ``int256``, but ``int8`` is not convertible to ``uint256``,
because ``uint256`` cannot hold values such as ``-1``.

اگر یک عملگر بر روی نوع‌های مختلف اعمال شود، کامپایلر سعی می‌کند به طور ضمنی یکی از عملوندها را به 
نوع دیگری تبدیل کند (این امر برای انتساب‌ها نیز صادق است). این بدان معناست که عملیات همیشه در نوع یکی از عملوندها انجام می‌شود.


برای جزئیات بیشتر در مورد اینکه کدام یک از تغییرات ضمنی امکان پذیر است، لطفاً با بخش‌هایی هر نوع مراجعه کنید.



در مثال زیر،  ``y`` و  ``z`` ، عملوندهای جمع، یک نوع ندارند، اما  ``uint8`` را می‌توان به طور ضمنی 
به  ``uint16`` تبدیل کرد و نه بالعکس. به همین دلیل،  ``y`` قبل از اینکه جمع در نوع  ``uint16`` انجام شود، 
به نوع  ``z`` تبدیل می‌شود.  ``uint16`` نوع حاصل از عبارت  ``y + z`` است. از آنجا که به یک متغیر از نوع 
``uint32`` اختصاص داده شده است، تبدیل ضمنی دیگر پس از جمع انجام می‌شود.



.. code-block:: solidity

    uint8 y;
    uint16 z;
    uint32 x = y + z;


 تبدیل‌های صریح  (Explicit Conversions)
--------------------
  اگر کامپایلر اجازه تبدیل ضمنی را ندهد اما اطمینان دارید که یک تبدیل کار می‌کند، تبدیل صریح نوع گاهی 
  اوقات امکان پذیر است. این ممکن است منجر به یک رفتار غیر منتظره شود و به شما امکان می‌دهد برخی از 
  ویژگی‌های امنیتی کامپایلر را دور بزنید، بنابراین مطمئن شوید که نتیجه همان چیزی است که شما می‌خواهید 
  و انتظار دارید!

 مثال زیر را در نظر بگیرید که  ``int`` منفی را به  ``uint`` تبدیل می‌کند:

.. code-block:: solidity

    int  y = -3;
    uint x = uint(y);

در انتهای این قطعه کد، ``x``  دارای مقدار ``0xfffff..fd``   (64 نویسه hex) است که در نمایش مکمل 256 بیت 3- (منفی سه) است.



اگر یک عدد صحیح صریح به یک نوع کوچکتر تبدیل شود، بیت‌های مرتبه بالاتر  بریده می‌شوند:



.. code-block:: solidity

    uint32 a = 0x12345678;
    uint16 b = uint16(a); // b will be 0x5678 now

اگر یک عدد صحیح صریح به یک نوع بزرگتر تبدیل شود، در سمت چپ (یعنی در انتهای مرتبه بالاتر) قرار 
می‌گیرد. نتیجه تبدیل برابر با عدد صحیح اصلی  خواهد بود:

.. code-block:: solidity

    uint16 a = 0x1234;
    uint32 b = uint32(a); // b will be 0x00001234 now
    assert(a == b);

نوع‌های بایت‌های با اندازه ثابت  در هنگام تبدیل متفاوت عمل می‌کنند. می‌توان آنها را به عنوان توالی بایت‌های 
فردی در نظر گرفت و تبدیل به نوع کوچکتر، توالی را قطع می‌کند:


.. code-block:: solidity

    bytes2 a = 0x1234;
    bytes1 b = bytes1(a); // b will be 0x12

اگر یک نوع بایت با اندازه ثابت صریحاً به یک نوع بزرگتر تبدیل شود، در سمت راست پر می‌شود. دستیابی به 
بایت در یک شاخص ثابت منجر به همان مقدار قبل و بعد از تبدیل خواهد شد (اگر شاخص هنوز در محدوده 
باشد):

.. code-block:: solidity

    bytes2 a = 0x1234;
    bytes4 b = bytes4(a); // b will be 0x12340000
    assert(a[0] == b[0]);
    assert(a[1] == b[1]);

ازآنجایی که آرایه‌های بایت با اندازه ثابت در هنگام کوتاه کردن یا پر کردن رفتار متفاوتی دارند، درصورتی که هر 
دو از اندازه یکسانی برخوردار باشند، تبدیل صریح بین اعداد صحیح و آرایه‌های بایت با اندازه ثابت مجاز است. اگر 
می‌خواهید بین اعداد صحیح و آرایه‌های بایت با اندازه ثابت با اندازه‌های مختلف تبدیل کنید، باید از تبدیلات 
میانی استفاده کنید که قوانین کوتاه کردن و پر کردن مورد نظر را صریح می‌کند:



.. code-block:: solidity

    bytes2 a = 0x1234;
    uint32 b = uint16(a); // b will be 0x00001234
    uint32 c = uint32(bytes4(a)); // c will be 0x12340000
    uint8 d = uint8(uint16(a)); // d will be 0x34
    uint8 e = uint8(bytes1(a)); // e will be 0x12

آرایه‌های ``bytes`` و برش‌های ``bytes`` کال‌دیتا را می‌توان به طور صریح به انواع بایت‌های ثابت (``bytes1``/…/``bytes32``) 
تبدیل کرد. در صورتی که آرایه طولانی تر از نوع بایت‌های ثابت هدف باشد، برش در انتها اتفاق می‌افتد. اگر آرایه کوتاهتر از نوع 
هدف باشد، در انتها با صفر پر می‌شود.


.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity ^0.8.5;

    contract C {
        bytes s = "abcdefgh";
        function f(bytes calldata c, bytes memory m) public view returns (bytes16, bytes3) {
            require(c.length == 16, "");
            bytes16 b = bytes16(m);  // if length of m is greater than 16, truncation will happen
            b = bytes16(s);  // padded on the right, so result is "abcdefgh\0\0\0\0\0\0\0\0"
            bytes3 b1 = bytes3(s); // truncated, b1 equals to "abc"
            b = bytes16(c[:8]);  // also padded with zeros
            return (b, b1);
        }
    }

.. _types-conversion-literals:

تبدیل بین لیترال‌ها و نوع‌های اصلی 
=================================================

انواع عدد صحیح  (Integer Types)
-------------
لیترال‌های عدد دسیمال و هگزادسیمال را می‌توان به طور ضمنی به هر نوع عددی صحیح که به اندازه کافی بزرگ 
باشد و بتوان آن را بدون کوتاه سازی نشان داد، تبدیل کرد:


.. code-block:: solidity

    uint8 a = 12; // fine
    uint32 b = 1234; // fine
    uint16 c = 0x123456; // fails, since it would have to truncate to 0x3456

.. note::

      قبل از نسخه 0.8.0، هر عدد تحت اعشاری یا هگزا دسیمال می‌تواند به ضمنی به یک نوع صحیح تبدیل 
      شود. از 0.8.0، چنین تبدیل‌های صریح به اندازه تبدیل‌های ضمنی سختگیرانه هستند، یعنی تنها در صورتی 
      مجاز هستند که کلمه تحت اللفظی در محدوده حاصله مطابقت داشته باشد.

آرایه‌های بایت با اندازه ثابت 
----------------------

اعداد اعشاری لیترال را نمی‌توان به صورت ضمنی به آرایه‌های بایت با اندازه ثابت تبدیل کرد. می‌تواند لیترال‌های 
عددی هگزادسیمال باشد، اما فقط در صورتی که تعداد ارقام هگز دقیقاً متناسب با اندازه نوع بایت  باشد. به عنوان 
ک استثنا، هر دو لیترال‌های دسیمال و هگزادسیمال که مقدار آنها صفر است، می‌توانند به هر تایپ بایت با اندازه 
با اندازه ثابت تبدیل شوند:



.. code-block:: solidity

    bytes2 a = 54321; // not allowed
    bytes2 b = 0x12; // not allowed
    bytes2 c = 0x123; // not allowed
    bytes2 d = 0x1234; // fine
    bytes2 e = 0x0012; // fine
    bytes4 f = 0; // fine
    bytes4 g = 0x0; // fine

اگر تعداد کاراکترهای آنها با اندازه نوع  بایت‌ها مطابقت داشته باشد، می‌توان لیترال‌های رشته‌ای و لیترال‌های 
رشته‌ای هگزی را به طور ضمنی به آرایه‌های بایت با اندازه ثابت تبدیل کرد:

.. code-block:: solidity

    bytes2 a = hex"1234"; // fine
    bytes2 b = "xy"; // fine
    bytes2 c = hex"12"; // not allowed
    bytes2 d = hex"123"; // not allowed
    bytes2 e = "x"; // not allowed
    bytes2 f = "xyz"; // not allowed

آدرس‌ها
---------

همانطور که در :ref:`آدرس لیترال‌ها<address_literals>` توضیح داده شد، لیترال‌های هگز با اندازه صحیح که از آزمون چک‌سام  عبور 
می‌کنند از نوع  ``address`` هستند. هیچ لیترال دیگری را نمی‌توان به طور ضمنی به 
نوع  ``address`` تبدیل کرد.


تبدیل صریح از  ``bytes20``  یا هر نوع عدد صحیح به  ``address`` منجر به ``address payable``  می‌شود.


``address a``  را می‌توان به ``address payable``  از طریق  ``payable(a)`` تبدیل کرد.

