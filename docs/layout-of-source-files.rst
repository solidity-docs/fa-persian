********************************
چیدمان یک فایل منبع سالیدیتی 
********************************

فایل‌های منبع  می‌توانند حاوی تعداد دلخواهی از :ref:`تعاریف قرارداد<contract_structure>`  ، دستور‌های ایمپورت ، دستور‌های :ref:`pragma directives<pragma>`  ، :ref:`struct<structs>` ، :ref:`enum<enums>`  ، :ref:`توابع<functions>`  ، :ref:`خطا<errors>`،  تعاریف :ref:`متغیر ثابت<constants>` باشند.

.. index:: ! license, spdx

مشخص کننده‌ی لایسنس  SPDX
=======================

در صورت در دسترس بودن کد منبع ، اعتماد به قرارداد هوشمند می‌تواند بهتر ایجاد شود. از آنجا که در دسترس قرار دادن کد منبع همیشه مشکلات حقوقی مربوط به حق چاپ را تحت تأثیر قرار می دهد، کامپایلر سالیدیتی استفاده از  `مشخص کنندهِ لایسنس SPDX <https://spdx.org>`_  قابلِ خوانده شدن توسطِ ماشین را ترغیب می‌کند. هر فایل منبع باید با یک کامنت که نشان دهد لایسنس آن است شروع شود:


``// SPDX-License-Identifier: MIT``



کامپایلر تأیید نمی‌کند که مجوز بخشی از  `لیستی <https://spdx.org/licenses/>`_   است که توسط SPDX مجاز است، اما رشته ارائه شده در :ref:`فرداداده بایت‌کد<metadata>` را شامل می‌شود. 

 اگر نمی‌خواهید مجوزی را تعیین نکنید یا اگر کد منبع، منبع باز نیست؛ لطفاً از مقدار ویژه  ``UNLICENSED``استفاده کنید. 

البته ارائه این کامنت شما را از سایر تعهدات مربوط به صدور لایسنس مانند نیاز به ذکر مجوز خاص در هِدر هر فایل منبع یا دارنده اصلی حق چاپ خلاص نمی کند.

کامنت توسط کامپایلر در هر کجای فایل در سطح فایل شناسایی می‌شود، اما توصیه می‌شود آن را در بالای فایل قرار دهید.

اطلاعات بیشتر در مورد نحوه استفاده از مشخص کننده لایسنس SPDX را می‌توانید در  `وب سایت  SPDX <https://spdx.org/ids-how>`_  بیابید.


.. index:: ! pragma

.. _pragma:

پراگماها
=======



کلمه کلیدی  ``pragma`` یا پراگما برای فعال کردن برخی از ویژگی‌های کامپایلر یا بررسی‌ها استفاده می‌شود. یک دستورالعمل پراگما همیشه محلی برای یک فایل منبع است، بنابراین اگر می‌خواهید آن را در کل پروژه خود فعال کنید، باید پراگما را به تمام فایل‌های خود اضافه کنید. اگر فایل‌ دیگری را  :ref:`ایمپورت<import>`  کنید، پراگمای آن فایل به طور خودکار در فایل وارد شده اعمال نمی‌شود.

.. index:: ! pragma, version

.. _version_pragma:

نسخه پراگما
--------------


  فایل‌های منبع را می‌توان (و باید) با یک نسخه ، نسخه بندی کرد تا کامپایل با نسخه‌های کامپایلر آتی را رد کند که ممکن است تغییرات ناسازگار را معرفی کند. ما سعی می‌کنیم این موارد را به حداقل برسانیم و آنها را به گونه ای معرفی کنیم که تغییر در سِمَنتیک‌ها  نیاز به تغییرسینتکس  داشته باشد، اما این امر همیشه امکان پذیر نیست. به همین دلیل، همیشه ایده خوبی است که حداقل برای نسخه‌هایی که شامل تغییرات خراب کننده هستند، از تغییرات جدید  استفاده کنید. این نسخه‌ها همیشه نسخه‌هایی از فرم ``x.0.0`` یا ``x.0.0`` دارند.


نسخه پراگما به شرح زیر استفاده می شود:  ``;pragma solidity ^0.5.2``

یک فایل منبع با خط بالا با یک کامپایلر جدیدتر از نسخه 0.5.2 کامپایل نمی‌شود و همچنین در یک کامپایلر که از نسخه 0.6.0 شروع می‌شود کار نمی‌کند (این شرط دوم با استفاده از  ``^`` اضافه می‌شود). از آنجا که تا قبل از نسخه  ``0.6.0`` هیچ تغییر جدید  ایجاد نخواهد شد، می‌توانید مطمئن باشید که کد شما به همان روشی که شما در نظر داشتید، کامپایل می‌شود. نسخه دقیق کامپایلر ثبت نشده است، بنابراین انتشار  رفع خطا  همچنان امکان پذیر است.

می‌توان قوانین پیچیده‌تری را برای نسخه کامپایلر تعیین کرد، اینها از همان سینتکسی  استفاده می‌کنند که توسط `npm <https://docs.npmjs.com/cli/v6/using-npm/semver>`_  استفاده می‌شود.

.. note::
 با استفاده از نسخه pragma نسخه کامپایلر *تغییر نمی‌کند*. همچنین ویژگی‌های کامپایلر را *فعال یا غیرفعال نمی‌کند*. این فقط به کامپایلر دستور می‌دهد که بررسی کند آیا نسخه آن با نسخه مورد نیاز پراگما مطابقت دارد یا خیر. اگر مطابقت نداشته باشد، کامپایلر خطایی را صادر می‌کند.

ABI Coder Pragma
----------------

  با استفاده از  ``pragma abicoder v1``  یا ``pragma abicoder v2``  می‌توانید از بین دو پیاده سازی رمزگذار  و رمزگشای  ABI یکی را انتخاب کنید.

رمزگذار جدید ABI (v2) قادر به رمزگذاری و رمزگشایی آرایه‌ها و structهای دلخواه تو در تو است. ممکن است کد بهینه کمتری تولید کند و به اندازه رمزگذار قدیمی تست نشده باشد، اما از نظر سالیدیتی نسخه 0.6.0 غیر آزمایشی محسوب می‌شود. شما هنوز هم باید با استفاده از  ``;pragma abicoder v2``  آن را صریحاً فعال کنید. در سالیدیتی نسخه 0.8.0 به طور پیش فرض فعال می‌شود، گزینه‌ای برای انتخاب کدگذار قدیمی با استفاده از  ``;pragma abicoder v1`` وجود دارد.

مجموعه نوع‌های  پشتیبانی شده توسط رمزگذار جدید یک مجموعه فوق العاده دقیق از نوع‌های پشتیبانی شده توسط رمزگذار قدیمی است. قراردادهایی که از آن استفاده می‌کنند می‌توانند با قراردادهایی که بدون محدودیت نیستند ارتباط برقرار کنند. بازگشت  فقط تا زمانی امکان پذیر است که قرارداد غیر ``abicoder v2``  سعی در فراخوانی‌هایی نداشته باشد که نیاز به انواع رمزگشایی داشته باشند که فقط توسط رمزگذار جدید پشتیبانی می‌شوند. کامپایلر می‌تواند این مورد را تشخیص دهد و خطایی ایجاد کند. فعال کردن ``abicoder v2``  قرارداد برای اینکه خطا برطرف شود، کافی است.

.. note::
  این پراگما برای همه کدهای تعریف شده در فایل در جایی که فعال شده‌است اعمال می‌شود، صرف نظر از اینکه سرانجام این کد به کجا ختم می‌شود. این بدان معناست که قراردادی که فایل منبع آن برای کامپایل با کدگذار ABI v1 انتخاب شده‌است، همچنان می‌تواند حاوی کدی باشد که با به ارث بردن رمزگذار جدید از قرارداد دیگر، از رمزگذار جدید استفاده کند. این درصورتی مجاز است که نوع‌های جدید فقط در داخل استفاده شوند و در امضاهای تابع خارجی نباشند.

.. note::
    تا سالیدیتی نسخه 0.7.4، می‌توان با استفاده از ``pragma experimental ABIEncoderV2`` ، رمزگذار ABI v2 را انتخاب کرد، اما صریحاً رمزگذار v1 را نمی‌توان انتخاب کرد زیرا پیش فرض بود.
  

.. index:: ! pragma, experimental

.. _experimental_pragma:

پراگما آزمایشی 
-------------------

پراگما دوم ، پراگما آزمایشی است. می‌توانند برای فعال کردن ویژگی‌های کامپایلر یا زبان استفاده شوند که هنوز به طور پیش فرض فعال نشده‌اند. پراگماهای آزمایشی زیر در حال حاضر پشتیبانی می‌شوند:



ABIEncoderV2
~~~~~~~~~~~~


از آنجا که رمزگذار ABI v2 دیگر آزمایشی محسوب نمی‌شود، می‌توان از طریق سالیدیتی نسخه 0.7.4 از طریق  ``pragma abicoder v2`` آن را انتخاب کرد (لطفاً به قسمت بالا مراجعه کنید).



.. _smt_checker:

کنترل کننده SMTC 
~~~~~~~~~~


این مؤلفه  باید در هنگام ساخت کامپایلر سالیدیتی فعال شود و بنابراین در تمام باینری‌های سالیدیتی در دسترس نیست.  :ref:`دستورالعمل‌های نسخه<smt_solvers_build>`  ،  نحوه فعال سازی این گزینه را توضیح می‌دهند. برای نسخه‌های اوبنتو  PPA در اکثر نسخه‌ها فعال شده، اما برای تصویر‌های داکر ، باینری‌های ویندوز  یا باینری‌های لینوکس نسخه ایستا ، فعال نیست. اگر یک حلال کننده  SMT را به صورت محلی نصب کرده باشید و solc-js را از طریق گره (نه از طریق مرورگر) اجرا کنید، می‌تواند از طریق  `smtCallback <https://github.com/ethereum/solc-js#example-usage-with-smtsolver-callback>`_    برای solc-js فعال شود.

اگر  ``;pragma experimental SMTChecker``  استفاده می‌کنید، :ref:`هشدارهای ایمنی<formal_verification>`   بیشتری دریافت می‌کنید که با پرس و جو از یک حل کننده SMT بدست می‌آیند. 

این مولفه هنوز از تمام ویژگی‌های زبان سالیدیتی پشتیبانی نمی‌کند و احتمالاً هشدارهای زیادی را در بر داشته باشد. در صورت گزارش ویژگی‌های پشتیبانی نشده، ممکن است تجزیه و تحلیل کاملاً مناسب نباشد.

.. index:: source file, ! import, module, source unit

.. _import:

ایمپورت کردن سایر فایل‌های منبع
============================

   سینتکس و سمنتیک 
--------------------

سالیدیتی برای کمک به ماژولی بودن کد شما که مشابه آنچه در جاوا اسکریپت در دسترس است (از ES6 به بعد)، از دستورات ایمپورت   پشتیبانی می‌کند. با این حال، سالیدیتی مفهوم  `اکسپورت به صورت پیشفرش <https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export#Description>`_ را پشتیبانی نمی‌کند. 

در سطح جهانی، می‌توانید از دستورات ایمپور  به شکل زیر استفاده کنید:



.. code-block:: solidity

    import "filename";

The ``filename`` part is called an *import path*.

این عبارت تمام نمادهای جهانی را از " filename " (و نمادهای وارد شده در آنجا) به دامنه جهانی فعلی ایمپورت می‌کند (متفاوت از ES6 اما برای سازگاری سالیدیتی با گذشته ). این فرم، برای استفاده توصیه نمی‌شود. زیرا به طور غیر قابل پیش بینی فضای نام را آلوده می‌کند. اگر موارد سطح بالای جدید را به داخل "namename" اضافه کنید، به طور خودکار در همه فایل‌هایی که از این "Filename" ایمپورت می‌شوند ظاهر می‌شوند. بهتر است نمادهای مشخص را به طور صریح وارد کنید.

  مثال زیر یک نماد جهانی   ``symbolName`` ایجاد می‌کند که اعضای آن همه نمادهای جهانی از  ``"filename"`` هستند:


.. code-block:: solidity

    import * as symbolName from "filename";


که منجر به در دسترس بودن همه نمادهای جهانی در قالب  ``symbolName.symbol`` می‌شود.

  گونه‌ای از این سینتکس که بخشی از ES6 نیست، اما احتمالاً قابل استفاده باشد:



.. code-block:: solidity

  import "filename" as symbolName;

که معادل  ``";import * as symbolName from "filename``  است.

 در صورت تصادم نامگذاری، می‌توانید هنگام ایمپورت کردن، نمادها را تغییر نام دهید. به عنوان مثال، کد زیر نمادهای جهانی جدید  ``alias`` و  ``symbol2`` را ایجاد می‌کند که به ترتیب از داخل  ``"filename"`` به  ``symbol1`` و  ``symbol2`` مراجعه می‌کند.



.. code-block:: solidity

    import {symbol1 as alias, symbol2} from "filename";

.. index:: virtual filesystem, source unit name, import; path, filesystem path, import callback, Remix IDE

ایمپورت مسیر‌ها 
------------

در موارد فوق،  filename همیشه به عنوان مسیری که با  / به عنوان جدا کننده دایرکتوری و  . به عنوان دایرکتوری فعلی  و  .. به عنوان دایرکتوری والد، رفتار می‌کند. زمانی که    .یا  .. با یک کاراکتر به جز  / دنبال شود، به عنوان پوشه اصلی یا والدین در نظر گرفته نمی‌شود. همه نام مسیرها به عنوان مسیرهای کامل برخورد می‌شوند مگر اینکه با دایرکتوری فعلی   . یا دایرکتوری والدین  .. شروع شوند. 

In order to be able to support reproducible builds on all platforms, the Solidity compiler has to
abstract away the details of the filesystem where source files are stored.
For this reason import paths do not refer directly to files in the host filesystem.
Instead the compiler maintains an internal database (*virtual filesystem* or *VFS* for short) where
each source unit is assigned a unique *source unit name* which is an opaque and unstructured identifier.
The import path specified in an import statement is translated into a source unit name and used to
find the corresponding source unit in this database.

Using the :ref:`Standard JSON <compiler-api>` API it is possible to directly provide the names and
content of all the source files as a part of the compiler input.
In this case source unit names are truly arbitrary.
If, however, you want the compiler to automatically find and load source code into the VFS, your
source unit names need to be structured in a way that makes it possible for an :ref:`import callback
<import-callback>` to locate them.
When using the command-line compiler the default import callback supports only loading source code
from the host filesystem, which means that your source unit names must be paths.
Some environments provide custom callbacks that are more versatile.
For example the `Remix IDE <https://remix.ethereum.org/>`_ provides one that
lets you `import files from HTTP, IPFS and Swarm URLs or refer directly to packages in NPM registry
<https://remix-ide.readthedocs.io/en/latest/import.html>`_.

For a complete description of the virtual filesystem and the path resolution logic used by the
compiler see :ref:`Path Resolution <path-resolution>`.

.. index:: ! comment, natspec

کامنت‌ها
========

کامنت‌های تک خطی (``//``) و کامنت‌های چند خطی  (``/*...*/``)امکان پذیر است.


.. code-block:: solidity

    // This is a single-line comment.

    /*
    This is a
    multi-line comment.
    */

.. note::
  یک کامنت تک خطی توسط هر پایان دهنده خط unicode (LF ، VF ، FF ، CR ، NEL ، LS یا PS) در رمزگذاری UTF-8 خاتمه می‌یابد. ترمیناتور  بعد از کامنت هنوز بخشی از کد منبع است، بنابراین اگر یک نماد ASCII نباشد (اینها NEL ، LS و PS هستند)، منجر به خطای تجزیه می‌شود.


علاوه بر این، نوع دیگری از کامنت به نام کامنت NatSpec وجود دارد که در :ref:`راهنمای استایل<style_guide_natspec>`  به تفصیل آورده شده است. آنها با یک اسلش سه گانه  (``///``) یا یک بلاک ستاره دوتایی  (``/** ... */``) نوشته می‌شوند و باید مستقیماً بالاتر از دستورات یا دستورات تابع استفاده شوند.


