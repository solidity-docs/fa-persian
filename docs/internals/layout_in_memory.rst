
.. index: memory layout

****************
چیدمان در مِمُوری (Layout in Memory)
****************

سالیدیتی چهار اسلات 32 بایتی را رزرو کرده که از محدوده‌های خاص (شامل نقاط پایانی) به شرح زیر استفاده شده:

- ``0x00`` - ``0x3f`` آ(64 bytes): فضای Scratch برای متدهای هش کردن
- ``0x40`` - ``0x5f`` آ(32 bytes): اندازه مِمُوری فعلی اختصاص داده شده (معروف به نشانگر حافظه آزاد )
- ``0x60`` - ``0x7f`` آ(32 bytes): اسلات صفر

فضای Scratch را می‌توان بین دستورات (به عنوان مثال در اسمبلی درون خطی) استفاده کرد. اسلات صفر به 
عنوان مقدار اولیه برای آرایه‌های مِمُوری داینامیک استفاده می‌شود و هرگز نباید روی آن نوشته شود (اشاره‌گر 
مِمُوری آزاد در ابتدا به ``0x80`` اشاره می‌کند).


سالیدیتی همیشه آبجکت‌های جدید را در نشانگر مِمُوری آزاد قرار می‌دهد و مِمُوری هرگز آزاد نمی‌شود (این 
ممکن است در آینده تغییر کند).



اِلمان‌های موجود در آرایه‌های مِمُوری در سالیدیتی همیشه مضربی از 32 بایت را اشغال می‌کنند (این حتی 
برای  ``[]bytes1`` صدق میکند، اما برای ``bytes`` و  ``string`` صادق نمی‌باشد  ). آرایه‌های مِمُوری چند 
بعدی نشانگر آرایه‌های مِمُوری هستند. طول یک آرایه داینامیک در اولین اسلات آرایه و به دنبال آن اِلمان‌های 
آرایه ذخیره می‌شود.




.. warning::

  برخی از عملیات در سالیدیتی وجود دارد که به فضای مِمُوری موقت بزرگتر از 64 بایت نیاز دارند و بنابراین در 
  فضای اسکرچ قرار نمی‌گیرند. آنها در جایی قرار می‌گیرند که مِمُوری آزاد به آن اشاره می‌کند، اما با توجه به 
  عمر کوتاه آنها، اشاره‌گر به روز نمی‌شود. مِمُوری ممکن است صفر شود یا صفر نشود. به همین دلیل، نباید 
  انتظار داشت که مِمُوری آزاد به مِمُوری صفر اشاره کند.



  اگرچه ممکن است استفاده از  ``msize`` برای رسیدن به یک فضای مِمُوری کاملاً صفر شده ایده خوبی به نظر 
  برسد، استفاده از چنین اشاره‌گری به‌طور غیرموقت و بدون به‌روزرسانی نشانگر مِمُوری آزاد می‌تواند نتایج 
  غیرمنتظره‌ای داشته باشد.
  


تفاوت چیدمان در Storage
================================

همانطور که در بالا توضیح داده شد، چیدمان در مِمُوری با چیدمان در :ref:`storage<storage-inplace-encoding>` متفاوت است. در زیر چند 
مثال وجود دارد.


مثالی برای تفاوت در آرایه‌ها
--------------------------------

آرایه زیر 32 بایت (1 اسلات) در storage اشغال می‌کند، اما 128 بایت (4 آیتم هر کدام با 32 بایت) در مِمُوری اشغال می‌کند.


.. code-block:: solidity

    uint8[4] a;



مثالی برای تفاوت در چیدمان Struct
---------------------------------------
ساختار زیر 96 بایت (3 اسلات 32 بایتی) در storage اشغال می‌کند، اما 128 بایت (4 آیتم هر کدام با 32 
بایت) در مِمُوری اشغال می‌کند.


.. code-block:: solidity

    struct S {
        uint a;
        uint b;
        uint8 c;
        uint8 d;
    }
