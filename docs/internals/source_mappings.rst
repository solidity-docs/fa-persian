.. index:: source mappings

***************
Mappingهای سورس
***************

به عنوان بخشی از خروجی AST، کامپایلر محدوده سورس‌کد را ارائه می‌دهد که توسط گره مربوطه در AST 
نشان داده می‌شود. این می‌تواند برای اهداف مختلفی استفاده شود از جمله ابزارهای آنالیز استاتیک که خطاها را 
بر اساس AST گزارش می‌کنند و ابزارهای اشکال زدایی  که متغیرهای محلی و کاربردهای آنها را برجسته می‌کنند.



علاوه بر این، کامپایلر همچنین می‌تواند یک mapping از بایت‌کد به محدوده سورس کدی که دستور را ایجاد 
کرده است، ایجاد کند. این دوباره برای ابزارهای آنالیز استاتیک که در سطح بایت‌کد کار می‌کنند و برای نمایش 
موقعیت فعلی در سورس‌کد در داخل یک دیباگر  یا برای رسیدگی به نقطه شکست مهم است. این mapping 
همچنین حاوی اطلاعات دیگری مانند تایپ jump  و عمق اصلاح کننده (modifier) است (به قسمت زیر 
مراجعه کنید).



هر دو تایپ mappingهای سورس از مشخص کننده‌های اینتیجر برای ارجاع به سورس فایل‌ استفاده می‌کنند. 
مشخص کننده یک سورس فایل در ``output['sources'][sourceName]['id']`` ذخیره می‌شود، جایی 
که  ``output`` خروجی اینترفیس کامپایلر استاندارد-json است که به‌عنوان JSON تجزیه می‌شود. برای برخی از 
روتین‌های کاربردی، کامپایلر سورس فایل‌های «داخلی(internal)» را تولید می‌کند که بخشی از ورودی اصلی 
نیستند، اما از mappingهای سورس ارجاع داده می‌شوند. این سورس فایل‌های همراه با مشخص کنندهایشان 
را می‌توان از طریق خروجی 
``output['contracts'][sourceName][contractName]['evm']['bytecode']['generatedSources']`` به دست 
آورد.



.. note ::

    در مورد دستورالعمل‌هایی که با هیچ سورس فایل خاصی مرتبط نیستند، سورس  mapping یک مشخص 
    کننده عدد اینتیجر   ``1-`` را اختصاص می‌دهد. این ممکن است برای بخش‌های بایت‌کد ناشی از دستورات 
    اسمبلی درون خطی تولید شده توسط کامپایلر اتفاق بیفتد.

سورس mapping در داخل AST از نشانه گذاری زیر استفاده می‌کند:


``s:l:f``

در جایی که  ``s`` مقدار بایت آفست شروع محدوده در سورس فایل است،  ``l`` طول محدوده سورس بر حسب بایت 
و  ``f`` ایندکس سورس ذکر شده در بالا است.


رمزگذاری در سورس mapping برای بایت‌کد پیچیده‌تر است: این لیستی از   ``s:l:f:j:m``  است که با  ``;`` از 
هم جدا شده‌است. هر یک از این اِلمان مربوط به یک دستورالعمل است، یعنی شما نمی‌توانید از آفست بایت 
استفاده کنید اما باید از آفست دستورالعمل استفاده کنید (دستورالعمل‌های push طولانی‌تر از یک بایت هستند). 
فیلدهای  ``s`` ، ``l``  و  ``f`` مانند بالا هستند. ``j``  می‌تواند  ``i`` ،  ``o`` یا  ``-`` باشد که نشان می‌دهد آیا دستور push 
به یک تابع می‌رود، از یک تابع برمی‌گردد یا یک push منظم به عنوان بخشی از، برای مثال یک حلقه باشد. 
آخرین فیلد،  ``m`` ، یک اینتیجر است که "عمق modifier " را نشان می‌دهد. هر زمان که (``_``) placeholder 
statement  در یک modifier وارد شود، این عمق افزایش می‌یابد و با رها کردن مجدد آن کاهش 
می‌یابد. این به دیباگرها اجازه می‌دهد موارد پیچیده را ردیابی کنند، مانند modifierای که دو بار استفاده 
می‌شود یا چندین  placeholder statements در یک modifier واحد استفاده می‌شود.


برای فشرده سازی این سورس mappingهای بخصوص برای بایت‌کد، از قوانین زیر استفاده می‌شود:



-	اگر یک فیلد خالی باشد، از value اِلمان قبلی استفاده می‌شود.
-	اگر یک  ``:`` وجود نداشته باشد، تمام فیلدهای بعدی خالی در نظر گرفته می‌شوند.


این بدان معنی است که سورس mapping زیر همان اطلاعات را نشان می‌دهد:


``2:1:2;2:1:2;2:1:2;1:9:1;1:2:1``

``;;2:1:2;9:;1:2:1``

نکته مهم این است که وقتی از   :ref:`verbatim <yul-verbatim>` builtin استفاده ‌شود، mapping سورس نامعتبر خواهد بود: 
builtin به جای چندتایی یک دستور واحد در نظر گرفته می‌شود.
