.. index:: optimizer, optimiser, common subexpression elimination, constant propagation
.. _optimizer:

*************
بهینه ساز (The Optimizer)
*************

کامپایلر سالیدیتی از دو ماژول بهینه ساز مختلف استفاده می‌کند: بهینه ساز « old» که در سطح آپکد عمل 
می‌کند و بهینه ساز « new» که بر روی کد Yul IR کار می‌کند.

بهینه ساز مبتنی بر آپکد، مجموعه ای از `قوانین ساده سازی <https://github.com/ethereum/solidity/blob/develop/libevmasm/RuleList.h>`_ را برای آپکدها اعمال می‌کند. همچنین 
مجموعه کدهای مساوی را ترکیب کرده و کدهای استفاده نشده را حذف می‌کند.

بهینه ساز مبتنی بر Yul بسیار قدرتمندتر است، زیرا می‌تواند در فراخوانی توابع کار کند. به عنوان مثال، 
جامپ‌های دلخواه در Yul امکان پذیر نیست، بنابراین می‌توان اثرات جانبی هر تابع را محاسبه کرد. دو فراخوانی 
تابع را در نظر بگیرید، که در آن اولی storage  را تغییر نمی دهد و دومی storage  را تغییر می‌دهد. اگر 
آرگومان‌ها و مقادیر بازگشتی آنها به یکدیگر وابسته نباشند، می‌توانیم فراخوانی‌های تابع را دوباره انجام بدهیم. 
به طور مشابه، اگر تابعی بدون اثرات جانبی باشد و نتیجه آن در صفر ضرب شود، می‌توانید فراخوانی تابع را به 
طور کامل حذف کنید.

در حال حاضر، پارامتر ``optimize--`` بهینه‌ساز مبتنی بر آپکد را برای بایت‌کد تولید شده و بهینه‌ساز Yul را 
برای کد Yul تولید شده به صورت داخلی فعال می‌کند، به عنوان مثال برای ABI coder v2. می‌توان از 
``solc --ir-optimized --optimize`` برای تولید یک Yul IR آزمایشی بهینه برای سورس سالیدیتی استفاده 
کرد. به طور مشابه، می‌توان از ``solc --strict-assembly --optimize`` برای حالت Yul مستقل استفاده 
کرد.

در زیر می‌توانید جزئیات بیشتری در مورد ماژول‌های بهینه ساز و مراحل بهینه سازی آنها بیابید.


مزایای بهینه سازی کد سالیدیتی
====================================

به طور کلی، بهینه ساز سعی می‌کند عبارات پیچیده را ساده کند، که هم اندازه کد و هم هزینه اجرا را کاهش 
می‌دهد، یعنی می‌تواند گَس مورد نیاز برای دیپلوی قرارداد و همچنین برای فراخوانی‌های خارجی انجام شده به 
قرارداد را کاهش دهد. همچنین توابع را تخصصی یا درون خطی می‌کند. به خصوص توابع درون‌ریزی عملیاتی 
است که می‌تواند باعث ایجاد کد بسیار بزرگ‌تر شود، اما اغلب انجام می‌شود زیرا فرصت‌هایی برای ساده‌سازی 
بیشتر ایجاد می‌کند.


تفاوت کدهای بهینه و غیربهینه
====================================================

به طور کلی، قابل مشاهده ترین تفاوت این است که عبارات ثابت در زمان کامپایل ارزیابی می‌شوند. وقتی صحبت 
از خروجی ASM می‌شود، می‌توان کاهش بلاک‌های کد معادل یا تکراری را نیز مشاهده کرد (خروجی فلگ‌های 
``asm--`` و ``asm --optimize--`` را مقایسه کنید). با این حال، وقتی صحبت از Yul/intermediate-
representation به میان می‌آید، ممکن است تفاوت‌های قابل توجهی وجود داشته باشد، برای مثال، ممکن 
است توابع خطی شوند، ترکیب شوند، یا بازنویسی شوند تا افزونگی‌ها حذف شوند، و غیره. (خروجی را بین فلگ‌های 
``ir--`` و ``--optimize --ir-optimized`` مقایسه کنید).


.. _optimizer-parameter-runs:

اجرای پارامترهای بهینه ساز 
========================

تعداد اجراها (``optimize-runs--``) تقریباً مشخص می‌کند که هر آپکدِ کد دیپلوی شده چند بار در طول عمر 
قرارداد اجرا می‌شود. این به این معنی است که یک پارامتر مبادله‌ای بین اندازه کد (هزینه دیپلوی) و هزینه اجرای 
کد (هزینه پس از دیپلوی) است. یک پارامتر "run" از "1" کد کوتاه اما گران قیمت تولید می‌کند. در مقابل، 
یک پارامتر " runs" بزرگتر کد طولانی‌تر اما کارآمدتر گاز تولید می‌کند. حداکثر مقدار پارامتر ```2**32-1`` است.


.. note::

    یک تصور غلط رایج این است که این پارامتر تعداد تکرارهای بهینه ساز را مشخص می‌کند. این درست نیست: 
    بهینه ساز همیشه هر چند بار که بتواند کد را بهبود ببخشد اجرا می شود.


ماژول بهینه ساز مبتنی بر آپکد
=============================


ماژول بهینه ساز مبتنی بر آپکد بر اساس کد اسمبلی کار می کند. توالی دستورالعمل ها را به بلاک‌های اصلی در 
``JUMPs`` و  ``JUMPDESTs`` تقسیم می‌کند. در داخل این بلوک‌ها، بهینه‌ساز دستورالعمل‌ها را آنالیز می‌کند و هر تغییری 
را در پشته، مِمُوری یا storage به‌عنوان عبارتی ثبت می‌کند که شامل یک دستورالعمل و فهرستی از آرگومان‌ها 
است که نشانگر عبارات دیگر هستند.


علاوه بر این، بهینه‌ساز مبتنی بر آپکد از کامپوننتی به نام «CommonSubexpressionEliminator» 
استفاده می‌کند که در میان سایر تسک‌ها، عباراتی را پیدا می‌کند که همیشه برابر هستند (در هر ورودی) و آنها 
را در یک کلاس عبارت ترکیب می‌کند. ابتدا سعی می‌کند هر عبارت جدید را در لیستی از عبارات از قبل شناخته 
شده پیدا کند. اگر چنین تطابقی یافت نشد، عبارت را با توجه به قوانینی 
مانند  ``constant + constant = sum_of_constants`` یا ``X * 1 = X`` ساده می‌کند. از آنجایی که این یک فرآیند 
بازگشتی است، اگر عامل دوم عبارت پیچیده‌تری باشد، می‌توانیم قانون دوم را نیز اعمال کنیم. که می‌دانیم همیشه 
به "یک" ارزیابی می‌شود.


برخی از مراحل بهینه ساز به طور نمادین مکان های storage  و مِمُوری را ردیابی می‌کنند. به عنوان مثال، این 
اطلاعات برای محاسبه هش Keccak-256 استفاده می‌شود که می‌تواند در طول زمان کامپایل ارزیابی شود. دنباله را در نظر بگیرید:

.. code-block:: none

    PUSH 32
    PUSH 0
    CALLDATALOAD
    PUSH 100
    DUP2
    MSTORE
    KECCAK256

یا معادل Yul

.. code-block:: yul

    let x := calldataload(0)
    mstore(x, 100)
    let value := keccak256(x, 32)

در این مورد، بهینه ساز مقدار را در یک مکان مِمُوری ``calldataload(0)`` ردیابی می‌کند و سپس متوجه می‌شود 
که هش Keccak-256 را می‌توان در زمان کامپایل ارزیابی کرد. این فقط در صورتی کار می‌کند که هیچ دستور 
دیگری وجود نداشته باشد که حافظه را بین ``mstore`` و ``keccak256`` تغییر دهد. بنابراین اگر دستوری وجود 
دارد که در مِمُوری (یا storage) می‌نویسد، باید دانش مِمُوری (یا storage) فعلی را پاک کنیم. با این حال، 
یک استثناء برای این پاک کردن وجود دارد، زمانی که ما به راحتی می‌توانیم ببینیم که دستورالعمل در یک مکان 
خاص نمی‌نویسد.

به عنوان مثال،

.. code-block:: yul

    let x := calldataload(0)
    mstore(x, 100)
    // Current knowledge memory location x -> 100
    let y := add(x, 32)
    // Does not clear the knowledge that x -> 100, since y does not write to [x, x + 32)
    mstore(y, 200)
    // This Keccak-256 can now be evaluated
    let value := keccak256(x, 32)

بنابراین، تغییرات در مکان‌های storage و مِمُوری، مثلاً مکان ``l`` ، باید دانش مربوط به مکان‌های storage یا 
مِمُوری را که ممکن است برابر با ``l`` باشد، پاک کند. به طور خاص، برای storage ، بهینه‌ساز باید تمام دانش 
مکان‌های نمادین را که ممکن است برابر با ``l`` باشد، و برای مِمُوری ، بهینه‌ساز باید تمام اطلاعات مکان‌های نمادین 
را که ممکن است حداقل ۳۲ بایت فاصله نداشته باشند، پاک کند. اگر ``m`` یک مکان دلخواه را نشان می دهد، پس 
این تصمیم در مورد پاک کردن با محاسبه مقدار ``sub(l, m)`` انجام می‌شود. برای storage ، اگر این مقدار به 
یک حرف غیر صفر ارزیابی شود، آنگاه دانش در مورد ``m`` حفظ خواهد شد. برای مِمُوری، اگر مقدار به معنای واقعی 
کلمه بین ``32`` و  ``2**256 - 32`` باشد، آنگاه دانش در مورد ``m`` حفظ خواهد شد. در تمام موارد دیگر، دانش در 
مورد ``m`` پاک خواهد شد.

پس از این فرآیند، ما می‌دانیم که در پایان کدام عبارات باید در پشته قرار گیرند و لیستی از تغییرات در مِمُوری 
و storage داریم. این اطلاعات همراه با بلاک‌های اصلی ذخیره می‌شود و برای پیوند آنها استفاده می‌شود. علاوه 
بر این، دانش در مورد پشته، storage و پیکربندی مِمُوری به بلوک(های) بعدی ارسال می‌شود.

اگر اهداف تمام دستورات  ``JUMP`` و ``JUMPI`` را بدانیم، می‌توانیم یک گراف جریان کنترل کامل برنامه را بسازیم. 
اگر فقط یک هدف وجود داشته باشد که ما نمی‌دانیم (این می‌تواند اتفاق بیفتد، همانطور که در اصل، اهداف 
JUMP را می‌توان از ورودی‌ها محاسبه کرد)، باید تمام اطلاعات مربوط به وضعیت ورودی یک بلاک را پاک کنیم، 
زیرا می‌تواند هدف JUMP ناشناخته باشد. . اگر ماژول بهینه ساز مبتنی بر کد یک ``JUMPI`` را پیدا کند که 
شرایط آن به یک ثابت ارزیابی می‌شود، آن را به یک ``JUMP`` بدون قید و شرط تبدیل می‌کند.



.. code-block:: solidity

    uint x = 7;
    data[7] = 9;
    if (data[x] != x + 2) // this condition is never true
      return 2;
    else
      return 1;

simplifies to this:

.. code-block:: solidity

    data[7] = 9;
    return 1;

Simple Inlining
---------------
از نسخه 0.8.2 سالیدیتی، مرحله بهینه‌ساز دیگری وجود دارد که با کپی از این دستورالعمل‌ها، جهش‌های 
خاصی را به بلوک‌های حاوی دستورالعمل‌های "ساده یا "simple که با "jump" ختم می‌شوند، جایگزین 
می‌کند و مربوط به توابع ساده و کوچک سالیدیتی یا Yul است. به طور خاص، دنباله ``PUSHTAG(tag) JUMP`` 
 ممکن است جایگزین شود، هر زمان که ``JUMP``  به عنوان پرش "into" یک تابع علامت گذاری شد و 
پشت ``tag`` یک بلوک اساسی وجود دارد (همانطور که در بالا برای 
"CommonSubexpressionEliminator" توضیح داده شد) که به ``JUMP``  دیگری ختم می شود. به 
عنوان پرش "خارج از" یک تابع مشخص شده است.


به طور خاص، نمونه اولیه زیر را در نظر بگیرید از اسمبلی که برای فراخوانی تابع سالیدیتی به صورت داخلی 
یا internal ایجاد شده است:


.. code-block:: text

      tag_return
      tag_f
      jump      // in
    tag_return:
      ...opcodes after call to f...

    tag_f:
      ...body of function f...
      jump      // out

تا زمانی که بدنه تابع یک بلوک پایه پیوسته است، "Inliner" می تواند جایگزین ``tag_f jump`` با بلوک در 
``tag_f`` شود که منجر به موارد زیر می شود:

.. code-block:: text

      tag_return
      ...body of function f...
      jump
    tag_return:
      ...opcodes after call to f...

    tag_f:
      ...body of function f...
      jump      // out

اکنون در حالت ایده‌آل، سایر مراحل بهینه‌ساز که در بالا توضیح داده شد باعث می‌شود که tag push 
برگشتی به سمت  jump  باقی‌مانده حرکت کند و در نتیجه:


.. code-block:: text

      ...body of function f...
      tag_return
      jump
    tag_return:
      ...opcodes after call to f...

    tag_f:
      ...body of function f...
      jump      // out

در این وضعیت "PeepholeOptimizer" پرش برگشت را حذف می کند. در حالت ایده‌آل، همه این 
کارها را می‌توان برای همه ارجاع‌ها به ``tag_f``  انجام داد و آن را بدون استفاده گذاشت، s.t. می توان آن را 
حذف کرد و نتیجه داد:

.. code-block:: text

    ...body of function f...
    ...opcodes after call to f...

بنابراین فراخوانی تابع ``f`` به صورت خطی است و می توان تعریف اصلی ``f`` را حذف کرد.



هر زمان که یک اکتشافی نشان می‌دهد که درون‌خط‌سازی در طول عمر قرارداد ارزان‌تر از inlining نیست، 
تلاش می‌شود. این اکتشاف به اندازه بدنه تابع، تعداد ارجاعات دیگر به تگ آن (تقریباً تعداد تماس‌های تابع) 
و تعداد مورد انتظار اجرای قرارداد (پارامتر بهینه‌ساز جهانی «اجرا می‌شود») بستگی دارد.


3.20.5 ماژول بهینه ساز مبتنی بر Yul
==========================

بهینه ساز مبتنی بر Yul از چندین مرحله و اجزا تشکیل شده است که همگی AST را به روشی معادل 
معنایی تبدیل می کنند. هدف این است که در نهایت کدهای کوتاه‌تر یا حداقل کمی طولانی‌تر داشته باشیم، 
اما مراحل بهینه‌سازی بیشتری را ممکن می‌سازد.


.. warning::

    از آنجایی که بهینه ساز در حال توسعه شدید است، ممکن است اطلاعات اینجا قدیمی باشد. اگر به عملکرد 
    خاصی متکی هستید، لطفاً مستقیماً با تیم تماس بگیرید.

بهینه ساز در حال حاضر از یک استراتژی پیروی می کند و هیچ عقبگردی انجام نمی دهد. 


تمام اجزای ماژول بهینه ساز مبتنی بر Yul در زیر توضیح داده شده است. مراحل تبدیل زیر اجزای اصلی هستند:

- تبدیل SSA
- حذف کننده Subexpression مشترک
- ساده کننده بیان
- مازاد تخصیص حذف
-  Inliner کامل

مراحل بهینه ساز
---------------

این لیستی از تمام مراحلی است که بهینه ساز مبتنی بر Yul بر اساس حروف الفبا مرتب شده است. در زیر 
می توانید اطلاعات بیشتری در مورد تک تک مراحل و ترتیب آنها بیابید.


- :ref:`block-flattener`.
- :ref:`circular-reference-pruner`.
- :ref:`common-subexpression-eliminator`.
- :ref:`conditional-simplifier`.
- :ref:`conditional-unsimplifier`.
- :ref:`control-flow-simplifier`.
- :ref:`dead-code-eliminator`.
- :ref:`equivalent-function-combiner`.
- :ref:`expression-joiner`.
- :ref:`expression-simplifier`.
- :ref:`expression-splitter`.
- :ref:`for-loop-condition-into-body`.
- :ref:`for-loop-condition-out-of-body`.
- :ref:`for-loop-init-rewriter`.
- :ref:`expression-inliner`.
- :ref:`full-inliner`.
- :ref:`function-grouper`.
- :ref:`function-hoister`.
- :ref:`function-specializer`.
- :ref:`literal-rematerialiser`.
- :ref:`load-resolver`.
- :ref:`loop-invariant-code-motion`.
- :ref:`redundant-assign-eliminator`.
- :ref:`reasoning-based-simplifier`.
- :ref:`rematerialiser`.
- :ref:`SSA-reverser`.
- :ref:`SSA-transform`.
- :ref:`structural-simplifier`.
- :ref:`unused-function-parameter-pruner`.
- :ref:`unused-pruner`.
- :ref:`var-decl-initializer`.

انتخاب بهینه سازی ها
-----------------------

به طور پیش فرض بهینه ساز دنباله از پیش تعریف شده مراحل بهینه سازی خود را برای مجموعه تولید 
شده اعمال می کند. شما می توانید این دنباله را override کنید و با استفاده از گزینه ``--yul-optimizations`` خود را عرضه کنید:


.. code-block:: bash

    solc --optimize --ir-optimized --yul-optimizations 'dhfoD[xarrscLMcCTU]uljmul'


دنباله داخل  ``[...]`` چندین بار در یک حلقه اعمال می شود تا زمانی که کد Yul بدون تغییر باقی بماند یا تا 
زمانی که به حداکثر تعداد دور (در حال حاضر 12) برسد. اختصارات موجود در اسناد یا همان بخش `داکیومنت  بهینه ساز Yul <yul.rst#optimization-step-sequence>`_ لیست شده است.

پیش پردازش(Preprocessing)
-------------
اجزای پیش‌پردازش، تبدیل‌هایی را انجام می‌دهند تا برنامه را به یک فرم معمولی خاص تبدیل کنند که کار 
با آن آسان‌تر باشد. این فرم معمولی در طول بقیه مراحل بهینه سازی حفظ می شود.


.. _disambiguator:

ابهام‌زدا(Disambiguator)
^^^^^^^^^^^^^
ابهام‌زدا یک AST می‌گیرد و یک کپی تازه برمی‌گرداند که در آن همه شناسه‌ها دارای نام‌های منحصربه‌فرد 
در ورودی AST هستند. این یک پیش نیاز برای تمام مراحل دیگر بهینه ساز است. یکی از مزایا این است که 
جستجوی شناسه نیازی به در نظر گرفتن دامنه ها ندارد که تجزیه و تحلیل مورد نیاز برای مراحل دیگر را 
ساده می کند. تمام مراحل بعدی این ویژگی را دارند که همه نام ها منحصر به فرد می مانند. این بدان معنی 
است که اگر یک شناسه جدید نیاز به معرفی داشته باشد، یک نام منحصر به فرد جدید تولید می شود.

.. _function-hoister:

FunctionHoister
^^^^^^^^^^^^^^^
hoister یا بالابر تابع تمام تعاریف تابع را به انتهای بالاترین بلوک منتقل می کند. تا زمانی که پس از 
مرحله ابهام‌زدایی انجام شود، این تبدیل از نظر معنایی معادل است. دلیل آن این است که انتقال یک تعریف 
به یک بلوک سطح بالاتر نمی تواند دید آن را کاهش دهد و نمی توان به متغیرهای تعریف شده در یک تابع 
متفاوت اشاره کرد.

مزیت این مرحله این است که تعاریف تابع را می توان آسانتر جستجو کرد و توابع را می توان به صورت مجزا 
و بدون نیاز به عبور کامل از AST بهینه کرد.


.. _function-grouper:

FunctionGrouper
^^^^^^^^^^^^^^^
گروه‌گر یا grouper تابع باید بعد از ابهام‌زدا و بالابر عملکرد اعمال شود. تأثیر آن این است که تمام عناصر 
برتر که تعاریف تابع نیستند به یک بلوک واحد منتقل می شوند که اولین عبارت بلوک ریشه یا root است. 


پس از این مرحله، یک برنامه به شکل عادی زیر است:


.. code-block:: text

    { I F... }

جایی که  ``I`` یک بلوک (بالقوه خالی) است که هیچ تعریف تابعی (حتی بازگشتی) ندارد و ``F`` لیستی از تعاریف 
تابع است به طوری که هیچ تابعی دارای تعریف تابع نیست. 



Where ``I`` is a (potentially empty) block that does not contain any function definitions (not even recursively)
and ``F`` is a list of function definitions such that no function contains a function definition.


مزیت این مرحله این است که ما همیشه می‌دانیم لیست توابع از کجا شروع می شود.


.. _for-loop-condition-into-body:

ForLoopConditionIntoBody
^^^^^^^^^^^^^^^^^^^^^^^^
این تبدیل شرایط تکرار حلقه یک حلقه for را به بدنه حلقه منتقل می کند. ما به این تبدیل نیاز داریم زیرا 
:ref:`expression-splitter` برای عبارات شرط تکرار (``C`` در مثال زیر) اعمال نمی شود.


.. code-block:: text

    for { Init... } C { Post... } {
        Body...
    }

تبدیل می شود به

is transformed to

.. code-block:: text

    for { Init... } 1 { Post... } {
        if iszero(C) { break }
        Body...
    }

این تبدیل زمانی که با ``LoopInvariantCodeMotion`` جفت می‌شود نیز می‌تواند مفید باشد، زیرا 
متغیرهای موجود در شرایط loopinvariant می‌توانند خارج از حلقه گرفته شوند.


.. _for-loop-init-rewriter:

ForLoopInitRewriter
^^^^^^^^^^^^^^^^^^^
این تبدیل، بخش اولیه یک حلقه for را به قبل از حلقه منتقل می کند:


.. code-block:: text

    for { Init... } C { Post... } {
        Body...
    }

تبدیل می شود به



.. code-block:: text

    {
        Init...
        for {} C { Post... } {
            Body...
        }
    }

این کار بقیه فرآیند بهینه‌سازی را آسان می‌کند، زیرا می‌توانیم قوانین محدوده‌بندی پیچیده بلوک اولیه‌ 
حلقه for را نادیده بگیریم.


.. _var-decl-initializer:

VarDeclInitializer
^^^^^^^^^^^^^^^^^^

مرحله اعلان های متغیر را بازنویسی می کند تا همه آنها مقداردهی اولیه شوند. اعلان هایی مانند ``let x, y`` 
به چند عبارت اعلان تقسیم می شوند. 


در حال حاضر فقط از مقداردهی اولیه با حرف صفر پشتیبانی می‌کند.


تبدیل شبه SSA (Pseudo-SSA Transformation)
-------------------------

هدف از این کامپوننت ها این است که برنامه را به شکل طولانی تری درآورد تا سایر اجزا بتوانند راحت تر با 
آن کار کنند. نمایش نهایی شبیه یک فرم تخصیص تک استاتیک (SSA) خواهد بود، با این تفاوت که از 
توابع صریح "phi" استفاده نمی کند که مقادیر شاخه های مختلف جریان کنترل را ترکیب می کند زیرا 
چنین ویژگی در آن وجود ندارد. زبان Yul در عوض، هنگامی که جریان کنترل ادغام می شود، اگر یک 
متغیر دوباره در یکی از شاخه ها تخصیص داده شود، یک متغیر SSA جدید برای حفظ مقدار فعلی خود 
اعلام می شود، به طوری که عبارات زیر هنوز فقط به متغیرهای SSA نیاز دارند. 


یک نمونه تبدیل به شرح زیر است:

.. code-block:: yul

    {
        let a := calldataload(0)
        let b := calldataload(0x20)
        if gt(a, 0) {
            b := mul(b, 0x20)
        }
        a := add(a, 1)
        sstore(a, add(b, 0x20))
    }

هنگامی که تمام مراحل تبدیل زیر اعمال می شود، برنامه به شکل زیر خواهد بود:


.. code-block:: yul

    {
        let _1 := 0
        let a_9 := calldataload(_1)
        let a := a_9
        let _2 := 0x20
        let b_10 := calldataload(_2)
        let b := b_10
        let _3 := 0
        let _4 := gt(a_9, _3)
        if _4
        {
            let _5 := 0x20
            let b_11 := mul(b_10, _5)
            b := b_11
        }
        let b_12 := b
        let _6 := 1
        let a_13 := add(a_9, _6)
        let _7 := 0x20
        let _8 := add(b_12, _7)
        sstore(a_13, _8)
    }

توجه داشته باشید که تنها متغیری که در این قطعه دوباره تخصیص داده شده است ``b`` است. از این تخصیص 
مجدد نمی توان اجتناب کرد زیرا ``b`` بسته به جریان کنترل مقادیر متفاوتی دارد. همه متغیرهای دیگر پس از 
تعریف، هرگز مقدار خود را تغییر نمی دهند. مزیت این ویژگی این است که متغیرها را می توان آزادانه جابجا 
کرد و ارجاع به آنها را می توان با مقدار اولیه آنها رد و بدل کرد (و بالعکس)، تا زمانی که این مقادیر هنوز در زمینه جدید معتبر هستند. 


البته کدهای اینجا با بهینه سازی فاصله زیادی دارد، برعکس، بسیار طولانی تر است. امید این است که کار با 
این کد آسان‌تر باشد و علاوه بر این، مراحل بهینه‌سازی وجود دارد که این تغییرات را خنثی می‌کند و در 
پایان دوباره کد را فشرده‌تر می‌کند.


.. _expression-splitter:

ExpressionSplitter
^^^^^^^^^^^^^^^^^^

عبارت تقسیم‌کننده عباراتی مانند ``add(mload(0x123), mul(mload(0x456), 0x20))`` را به 
دنباله‌ای از اعلان‌های متغیرهای منحصربه‌فرد تبدیل می‌کند که به عبارت‌های فرعی آن عبارت اختصاص 
داده می‌شود، به طوری که هر فراخوانی تابع فقط دارای متغیرهایی به عنوان آرگومان است. 


The expression splitter turns expressions like ``add(mload(0x123), mul(mload(0x456), 0x20))``
into a sequence of declarations of unique variables that are assigned sub-expressions
of that expression so that each function call has only variables or literals
as arguments.

موارد فوق تبدیل به


.. code-block:: yul

    {
        let _1 := mload(0x123)
        let _2 := mul(_1, 0x20)
        let _3 := mload(0x456)
        let z := add(_3, _2)
    }

توجه داشته باشید که این تبدیل ترتیب آپکدها یا فراخوانی تابع را تغییر نمی دهد. 



برای شرط تکرار حلقه اعمال نمی شود، زیرا جریان کنترل حلقه اجازه این "طرح بندی" عبارات داخلی را 
در همه موارد نمی دهد. ما می‌توانیم با اعمال :ref:`for-loop-condition-into-body` برای انتقال شرط تکرار 
به بدنه حلقه، این محدودیت را کنار بگذاریم.


برنامه نهایی باید به شکلی باشد که (به استثنای شرایط حلقه) فراخوانی های تابع نتوانند به صورت تودرتو 
در داخل عبارات ظاهر شوند و همه آرگومان های فراخوانی تابع باید متغیر باشند. 

مزایای این فرم این است که مرتب کردن ترتیب آپکدها بسیار آسان تر است و همچنین انجام 
فراخوانی توابع درون خطی آسان تر است. علاوه بر این، جایگزین کردن بخش‌های جداگانه عبارات یا 
سازماندهی مجدد «درخت بیان(expression tree) ساده‌تر است. اشکال این است که خواندن چنین 
کدی برای انسان بسیار سخت تر است.

.. _SSA-transform:

SSATransform
^^^^^^^^^^^^

این مرحله سعی می‌کند تا حد امکان جایگزین انتساب‌های مکرر به متغیرهای موجود با اعلان‌های متغیرهای 
جدید شود. تخصیص مجدد هنوز وجود دارد، اما همه ارجاعات به متغیرهای تخصیص مجدد با متغیرهای 
جدید اعلام شده جایگزین می شوند.



مثال:



.. code-block:: yul

    {
        let a := 1
        mstore(a, 2)
        a := 3
    }

تبدیل می شود به



.. code-block:: yul

    {
        let a_1 := 1
        let a := a_1
        mstore(a_1, 2)
        let a_3 := 3
        a := a_3
    }


معناشناسی دقیق (Exact semantics):

برای هر متغیر ``a`` که به جایی از کد اختصاص داده شده است (متغیرهایی که با مقدار اعلان می شوند و 
هرگز دوباره تخصیص داده نمی شوند، تغییر نمی کنند) تبدیل های زیر را انجام دهید:

- جایگذین کنید ``let a := v`` با ``let a_i := v   let a := a_i``
- جایگذین کنید ``a := v`` با ``let a_i := v   a := a_i`` زمانی که ``i`` یک عددی مانند این   ``a_i`` هنوز استفاده نشده باشد.

علاوه بر این، همیشه مقدار فعلی ``i`` استفاده شده برای ``a``  را ثبت کنید و هر ارجاع به ``a``  را با ``a_i`` جایگزین 
کنید. mapping مقدار فعلی برای متغیر ``a``  در انتهای هر بلوکی که در آن به آن اختصاص داده شده است 
می‌شود. اگر مقدار یک متغیر طبق قانون بالا پاک شود و متغیر خارج از بلوک اعلام شود، یک متغیر SSA 
جدید در محلی که جریان کنترل به آن می پیوندد ایجاد می شود که شامل ابتدای حلقه پست/بلوک بدنه و 
مکان عبارت If/Switch/ForLoop/Blockبلافاصله بعد از آن است. 


پس از این مرحله، Redundant Assign Eliminator برای حذف تکالیف غیر ضروری میانی توصیه می‌شود.

اگر Expression Splitter و Common Subexpression Eliminator درست قبل از آن اجرا شوند، 
این مرحله بهترین نتایج را ارائه می دهد، زیرا در این صورت مقادیر زیادی متغیر تولید نمی کند. از سوی 
دیگر، Common Subexpression Eliminator اگر بعد از تبدیل SSA اجرا شود، می تواند کارآمدتر 
باشد.


.. _redundant-assign-eliminator:

RedundantAssignEliminator
^^^^^^^^^^^^^^^^^^^^^^^^^

تبدیل SSA همیشه یک انتساب به شکل ``a := a_i`` ایجاد می کند، حتی اگر اینها در بسیاری از موارد غیر 
ضروری باشند، مانند مثال زیر:

.. code-block:: yul

    {
        let a := 1
        a := mload(a)
        a := sload(a)
        sstore(a, 1)
    }

تبدیل SSA این قطعه را به شکل زیر تبدیل می کند:

.. code-block:: yul

    {
        let a_1 := 1
        let a := a_1
        let a_2 := mload(a_1)
        a := a_2
        let a_3 := sload(a_2)
        a := a_3
        sstore(a_3, 1)
    }

Redundant Assign Eliminator هر سه تخصیص به ``a`` را حذف می‌کند، زیرا از مقدار ``a`` استفاده 
نمی‌شود و بنابراین این قطعه را به فرم SSA تبدیل می‌کند:


.. code-block:: yul

    {
        let a_1 := 1
        let a_2 := mload(a_1)
        let a_3 := sload(a_2)
        sstore(a_3, 1)
    }

البته بخش های پیچیده تعیین اینکه آیا یک تخصیص اضافی است یا نه به جریان کنترل متصل است.


کامپوننت با جزئیات به شرح زیر عمل می کند:

AST دو بار عبور می کند: در مرحله جمع آوری اطلاعات و در مرحله حذف واقعی. در طول جمع‌آوری 
اطلاعات، ما یک mapping از گزاره‌های تخصیص به سه حالت «استفاده نشده»، «تصمیم‌نشده» و 
«استفاده شده» را حفظ می‌کنیم که نشان می‌دهد آیا مقدار تخصیص‌یافته بعداً با ارجاع به متغیر مورد 
استفاده قرار می‌گیرد یا خیر.


هنگامی که یک انتساب بازدید می شود، در حالت "تصمیم نشده" به mapping اضافه می شود (به نکته 
در مورد حلقه های زیر مراجعه کنید) و هر تخصیص دیگری به همان متغیری که هنوز در حالت "تصمیم 
نشده" است به "unused" تغییر می یابد. هنگامی که یک متغیر ارجاع داده می شود، وضعیت هر انتساب 
به آن متغیر هنوز در حالت "تصمیم نشده" به "استفاده شده" تغییر می کند. در نقاطی که جریان کنترل 
تقسیم می شود، یک نسخه از mapping  به هر شاخه تحویل داده می شود. در نقاطی که جریان کنترل به 
هم می پیوندد، دو mapping حاصل از دو شاخه به روش زیر ترکیب می شوند: عباراتی که فقط در یک 
mapping هستند یا حالت یکسانی دارند، بدون تغییر استفاده می شوند. مقادیر متناقض به روش زیر حل 
می شوند:


- "unused", "undecided" -> "undecided"
- "unused", "used" -> "used"
- "undecided, "used" -> "used"

برای حلقه‌های for، شرط، بدنه و پس‌پارت(post-part) دو بار بازدید می‌شوند و جریان کنترل اتصال در 
شرایط را در نظر می‌گیرند. به عبارت دیگر، ما سه مسیر جریان کنترلی ایجاد می کنیم: صفر اجرای حلقه، 
یک اجرا و دو اجرا و سپس آنها را در پایان ترکیب می کنیم. شبیه سازی اجرای سوم یا حتی بیشتر غیر 
ضروری است که به صورت زیر قابل مشاهده است:


وضعیت یک تکلیف در ابتدای تکرار به طور قطعی منجر به وضعیت آن تخصیص در پایان تکرار می شود. 
اجازه دهید این تابع mapping حالت ``f`` نامیده شود. ترکیبی از سه حالت مختلف ``unused``، ``undecided`` 
و ``used``  همانطور که در بالا توضیح داده شد ``max`` عملیاتی است که در آن ``unused = 0``، 
``undecided = 1`` و ``used = 2`` است. 


The proper way would be to compute

.. code-block:: none

    max(s, f(s), f(f(s)), f(f(f(s))), ...)

روش صحیح محاسبه حالت بعد از حلقه خواهد بود. از آنجایی که f فقط دارای محدوده ای از سه مقدار 
مختلف است، تکرار آن باید حداکثر پس از سه بار تکرار به یک چرخه برسد و بنابراین ``f(f(f(s)))`` باید برابر با 
یکی از ``s``، ``f(s)`` یا ``f(f(s))`` باشد  و بنابراین



.. code-block:: none

    max(s, f(s), f(f(s))) = max(s, f(s), f(f(s)), f(f(f(s))), ...).

 به طور خلاصه، اجرای حلقه حداکثر دو بار کافی است زیرا فقط سه حالت مختلف وجود دارد.


برای عبارات سوئیچ که دارای حالت "پیش فرض" هستند، هیچ بخش کنترل جریانی وجود ندارد که سوئیچ 
را رد کند. 

هنگامی که متغیری از محدوده خارج می شود، تمام عباراتی که هنوز در حالت "تصمیم نشده" هستند به 
"unused" تغییر می کنند، مگر اینکه متغیر پارامتر بازگشتی یک تابع باشد - در آنجا، وضعیت به 
"استفاده شده" تغییر می کند. 


در پیمایش دوم، تمام تکالیفی که در حالت "استفاده نشده" هستند حذف می شوند.

 این مرحله معمولاً درست پس از تبدیل SSA برای تکمیل تولید شبه SSA اجرا می شود.
 
ابزارها
-----

قابلیت جابجایی (Movability)
^^^^^^^^^^
قابل انتقال بودن ویژگی یک عبارت است. تقریباً به این معنی است که عبارت عاری از عوارض جانبی است و 
ارزیابی آن فقط به مقادیر متغیرها و وضعیت ثابت تماس محیط بستگی دارد. اکثر عبارات قابل انتقال هستند.
قسمت های زیر یک عبارت را غیر قابل انتقال می کنند:


- فراخوانی های تابع (اگر همه دستورات در تابع قابل انتقال باشند، ممکن است در آینده راحت تر شوند)
- کدهایی که (می توانند) دارای اثرات جانبی باشند (مانند ``call`` یا ``selfdestruct``)
- کدهای باز که اطلاعات حافظه، ذخیره سازی یا وضعیت خارجی را می خوانند یا می نویسند
-  آپکدها که به رایانه فعلی، اندازه حافظه یا اندازه داده بازگشتی بستگی دارد



DataflowAnalyzer
^^^^^^^^^^^^^^^^

Dataflow Analyzer به خودی خود یک مرحله بهینه ساز نیست بلکه به عنوان ابزاری توسط اجزای 
دیگر استفاده می شود. هنگام عبور از AST، مقدار فعلی هر متغیر را تا زمانی که آن مقدار یک عبارت 
قابل انتقال باشد، ردیابی می کند. متغیرهایی را که بخشی از عبارتی هستند که در حال حاضر به یک متغیر 
دیگر اختصاص داده شده اند را ثبت می کند. پس از هر انتساب به یک متغیر  ``a``، مقدار ذخیره شده فعلی  ``a`` 
به روز می شود و هر زمان که  ``a`` بخشی از عبارت ذخیره شده فعلی برای ``b`` باشد، همه مقادیر ذخیره شده 
همه متغیرهای ``b`` پاک می شوند.

در اتصالات جریان-کنترل، اگر متغیرها در هر یک از مسیرهای جریان-کنترل تخصیص داده شوند، دانش در 
مورد متغیرها پاک می شود. به عنوان مثال، با وارد کردن یک حلقه for، همه متغیرهایی که در طول بدنه یا 
بلوک پست اختصاص داده می شوند، پاک می شوند.


ساده سازی بیان مقیاس (Expression-Scale Simplifications)
--------------------------------

این پاس‌های ساده‌سازی، عبارات را تغییر می‌دهند و آن‌ها را با عبارات معادل و امیدواریم ساده‌تر جایگزین 
می‌کنند.


.. _common-subexpression-eliminator:

CommonSubexpressionEliminator
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
این مرحله از DataflowAnalyzer استفاده می‌کند و عبارات فرعی را جایگزین می‌کند که از نظر نحوی 
با مقدار فعلی یک متغیر مطابقت دارند، با ارجاع به آن متغیر. این یک تبدیل معادل است زیرا چنین عبارات 
فرعی باید قابل انتقال باشند.



اگر مقدار یک شناسه باشد، تمام عبارات فرعی که خود شناسه هستند، با مقدار فعلی آنها جایگزین می 
شوند.

ترکیب دو قانون فوق به شما امکان می دهد تا یک عدد محلی را محاسبه کنید، به این معنی که اگر دو 
متغیر دارای مقدار یکسان باشند، یکی از آنها همیشه استفاده نمی شود. استفاده نشده یا حذف کننده 
تخصیص اضافی می توانند چنین متغیرهایی را به طور کامل حذف کنند.


این مرحله به ویژه در صورتی کارآمد است که عبارت splitter قبلا اجرا شده باشد. اگر کد به شکل شبه 
SSA باشد، مقادیر متغیرها برای مدت زمان بیشتری در دسترس هستند و بنابراین شانس بیشتری برای 
جایگزینی عبارات داریم.



در صورتی که حذف کننده عبارات فرعی رایج درست قبل از آن اجرا شود، ساده‌کننده عبارت می‌تواند 
جایگزین‌های بهتری را انجام دهد.


.. _expression-simplifier:

ساده کننده بیان (Expression Simplifier)
^^^^^^^^^^^^^^^^^^^^^
Simplifier Expression از Dataflow Analyzer استفاده می کند و از لیستی از تبدیل های معادل 
در عباراتی مانند  ``X + 0 -> X``  برای ساده کردن کد استفاده می کند.



سعی می کند الگوهایی مانند    ``X + 0`` را در هر زیر عبارت مطابقت دهد. در طول رویه تطبیق، متغیرها را به 
عبارات اختصاص داده شده فعلی آنها حل می کند تا بتواند الگوهای تودرتو عمیق تری را حتی زمانی که کد 
به شکل شبه SSA است مطابقت دهد.



برخی از الگوها مانند ``X - X -> 0``  را فقط تا زمانی می توان اعمال کرد که عبارت ``X``
 قابل انتقال باشد، زیرا در 
غیر این صورت عوارض جانبی احتمالی آن را از بین می برد. از آنجایی که مراجع متغیر همیشه قابل 
جابجایی هستند، حتی اگر مقدار فعلی آن‌ها نباشد، ساده‌کننده بیان مجدداً در قالب تقسیم یا شبه SSA 
قدرتمندتر است.


.. _literal-rematerialiser:

LiteralRematerialiser
^^^^^^^^^^^^^^^^^^^^^

مستند شود.

.. _load-resolver:

LoadResolver
^^^^^^^^^^^^
مرحله بهینه سازی که عبارات نوع ``sload(x)`` و ``mload(x)`` را با مقداری که در حال حاضر در ذخیره سازی 
ذخیره می شود جایگزین می کند. حافظه، در صورت شناخته شدن.

اگر کد به شکل SSA باشد بهترین کار را دارد.

Works best if the code is in SSA form.

پیش نیاز: Disambiguator، ForLoopInitRewriter.

Prerequisite: Disambiguator, ForLoopInitRewriter.

.. _reasoning-based-simplifier:

ReasoningBasedSimplifier
^^^^^^^^^^^^^^^^^^^^^^^^
این بهینه ساز از حل کننده های SMT برای بررسی ثابت بودن شرایط ``if`` استفاده می کند.

- اگر ``constraints AND condition`` UNSAT باشد، این شرط هرگز درست نیست و کل بدن را می توان برداشت.

-  اگر ``constraints AND NOT condition`` UNSAT باشد، شرط همیشه درست است و می تواند با 1 
جایگزین شود.


ساده‌سازی‌های بالا فقط در صورتی قابل اعمال هستند که شرط قابل انتقال باشد.


 این فقط در EVM موثر است، اما برای استفاده در گویش های دیگر بی خطر است.
 
  پیش نیاز: 
Disambiguator، SSATtransform.


بیانیه-مقیاس ساده سازی
-------------------------------

.. _circular-reference-pruner:

CircularReferencesPruner
^^^^^^^^^^^^^^^^^^^^^^^^

این مرحله توابعی را حذف می کند که یکدیگر را فراخوانی می کنند اما نه ارجاع خارجی دارند و نه از بیرونی 
ترین زمینه ارجاع می شوند.


.. _conditional-simplifier:

ساده کننده شرطی
^^^^^^^^^^^^^^^^^^^^^
اگر بتوان مقدار را از طریق جریان کنترل تعیین کرد، ساده‌کننده شرطی، انتساب‌ها را به متغیرهای شرط 
وارد می‌کند.

فرم SSA را از بین می برد.



در حال حاضر، این ابزار بسیار محدود است، بیشتر به این دلیل که ما هنوز از انواع Boolean پشتیبانی 
نمی کنیم. از آنجایی که شرایط فقط غیر صفر بودن عبارات را بررسی می کنند، نمی توانیم مقدار خاصی را 
تعیین کنیم.


ویژگی های فعلی:


-	موارد سوئیچ: "<condition> := <caseLabel>" را وارد کنید
-	بعد از دستور if با کنترل جریان پایان دهنده، "<condition> := 0" را درج کنید ویژگی های 



ویژگی‌های آتی:

-	اجازه جایگزینی با "1"
-	خاتمه عملکردهای تعریف شده توسط کاربر را در نظر بگیرید 


با فرم SSA و اگر حذف کد مرده قبلاً اجرا شده باشد بهترین کار را می کند. 



پیش نیاز: Disambiguator.



.. _conditional-unsimplifier:

ConditionalUnsimplifier
^^^^^^^^^^^^^^^^^^^^^^^
معکوس ساده کننده شرطی.


.. _control-flow-simplifier:

ControlFlowSimplifier
^^^^^^^^^^^^^^^^^^^^^
چندین ساختار کنترل جریان را ساده می کند:


- اگر با بدنه خالی با pop(شرط) جایگزین شود
- بخش سوئیچ پیش فرض خالی را بردارید
- اگر مورد پیش فرض وجود نداشته باشد، مورد سوئیچ خالی را حذف کنید
- تعویض سوئیچ بدون قاب با pop(expression)
- سوئیچ تک کیس را به if تبدیل کنید
- سوئیچ را تنها با حالت پیش فرض با pop(expression) و بدنه جایگزین کنید
- سوئیچ را با const expr با بدنه مورد منطبق جایگزین کنید
- ``for`` را با جریان کنترل خاتمه دهنده و بدون شکست دیگر جایگزین کنید/با ``if`` ادامه دهید
- حذف ``leave`` در پایان یک تابع.



هیچ یک از این عملیات به جریان داده بستگی ندارد. StructuralSimplifier وظایف مشابهی را انجام 
می‌دهد که به جریان داده بستگی دارد.


ControlFlowSimplifier وجود یا عدم وجود ``break`` و عبارات  ``continue`` را در طول پیمایش ثبت می کند.


پیش نیاز: Disambiguator، FunctionHoister، ForLoopInitRewriter. 



مهم: کدهای EVM را معرفی می کند و بنابراین فعلاً فقط می تواند در کد EVM استفاده شود.


.. _dead-code-eliminator:

DeadCodeEliminator
^^^^^^^^^^^^^^^^^^
این مرحله بهینه سازی کدهای غیرقابل دسترسی را حذف می کند.


کد غیرقابل دسترسی به هر کدی در یک بلوک گفته می‌شود که قبل از آن ترک، بازگشت، نامعتبر، شکست، 
ادامه، خود تخریب یا بازگردانی وجود دارد.



تعاریف تابع همانطور که ممکن است با کد قبلی فراخوانی شوند حفظ می شوند و بنابراین قابل دسترسی در 
نظر گرفته می شوند.


از آنجایی که متغیرهای اعلام شده در بلوک اولیه حلقه for، دامنه آنها تا بدنه حلقه گسترش یافته است، ما قبل از این مرحله 
به اجرای ForLoopInitRewriter نیاز داریم.


پیش نیاز: ForLoopInitRewriter، Function Hoister، Function Grouper



.. _unused-pruner:

UnusedPruner
^^^^^^^^^^^^

این مرحله تعاریف همه توابعی را که هرگز به آنها ارجاع داده نمی شود حذف می کند. 
همچنین اعلان متغیرهایی را که هرگز ارجاع داده نمی شوند حذف می کند. اگر اعلان مقداری را اختصاص 
دهد که قابل انتقال نیست، عبارت حفظ می شود، اما مقدار آن کنار گذاشته می شود.
تمام عبارات عبارت قابل انتقال (عباراتی که اختصاص داده نشده اند) حذف می شوند.



.. _structural-simplifier:

ساده ساز ساختاری
^^^^^^^^^^^^^^^^^^^^

این یک مرحله کلی است که انواع مختلفی از ساده سازی ها را در سطح ساختاری انجام می دهد:

- دستور if را با متن خالی با ``pop(condition)`` جایگزین کنید
- دستور if را با شرط true با بدنه آن جایگزین کنید
- دستور if را با شرط نادرست حذف کنید
- سوئیچ تک کیس را به if تبدیل کنید
- سوئیچ را تنها با حالت پیش فرض بوسیله ``pop(expression)`` و بدنه جایگزین کنید
- با تطبیق بدنه حروف، کلید را با عبارت لیترال جایگزین کنید
- حلقه را با شرط false با قسمت اولیه آن جایگزین کنید

این کامپوننت از Dataflow Analyzer استفاده می کند.

.. _block-flattener:

BlockFlattener
^^^^^^^^^^^^^^

این مرحله بلوک های تودرتو را با درج عبارت در بلوک داخلی در محل مناسب بلوک بیرونی حذف می کند. 
به FunctionGrouper بستگی دارد و بیرونی ترین بلوک را برای حفظ فرم تولید شده توسط 
FunctionGrouper صاف نمی کند.



.. code-block:: yul

    {
        let x := 2
        {
            let y := 3
            mstore(x, y)
        }
    }
تبدیل می شود به


.. code-block:: yul

    {
        let x := 2
        let y := 3
        mstore(x, y)
    }

تا زمانی که کد مبهم باشد، این مشکلی ایجاد نمی کند زیرا دامنه متغیرها فقط می تواند رشد کند.


.. _loop-invariant-code-motion:

LoopInvariantCodeMotion
^^^^^^^^^^^^^^^^^^^^^^^

این بهینه سازی اعلان های متغیر SSA قابل انتقال را به خارج از حلقه منتقل می کند.

فقط عبارات در سطح بالا در بدنه حلقه یا بلوک پست در نظر گرفته می شوند، یعنی اعلان های متغیر در 
شاخه های شرطی از حلقه خارج نمی شوند.

الزامات:

- Disambiguator، ForLoopInitRewriter و FunctionHoister باید از قبل اجرا شوند.
- تقسیم بیان و تبدیل SSA باید از قبل اجرا شوند تا نتیجه بهتری بدست آید.


Function-Level Optimizations
----------------------------

.. _function-specializer:

بهینه سازی در سطح عملکرد
^^^^^^^^^^^^^^^^^^^

این مرحله تابع را با آرگومان های لیترال آن تخصصی می کند.


اگر یک تابع، مثلاً، تابع ``function f(a, b) { sstore (a, b) }``  با آرگومان های لیترال فراخوانی شود، به عنوان 
مثال،  ``f(x, 5)``، که در آن ``x`` یک شناسه است، می توان آن را با ایجاد تخصصی کرد. یک تابع جدید ``f_1`` که 
فقط یک آرگومان می گیرد، به عنوان مثال،


.. code-block:: yul

    function f_1(a_1) {
        let b_1 := 5
        sstore(a_1, b_1)
    }

سایر مراحل بهینه سازی قادر خواهند بود تا عملکرد را ساده تر کنند. مرحله بهینه سازی عمدتاً برای توابعی 
مفید است که درون خطی نیستند.

پیش نیازها: Disambiguator، FunctionHoister LiteralRematerialiser به عنوان یک پیش 
نیاز توصیه می شود، حتی اگر برای صحت لازم نباشد.



.. _unused-function-parameter-pruner:

UnusedFunctionParameterPruner
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

این مرحله پارامترهای استفاده نشده در یک تابع را حذف می کند. 

اگر پارامتری مانند ``c`` و ``y`` در   ``function f(a,b,c) -> x, y { x := div(a,b) }``   استفاده نشده باشد، پارامتر را حذف 
کرده و یک تابع "پیوند یا linking" جدید ایجاد می کنیم. به شرح زیر است:


.. code-block:: yul

    function f(a,b) -> x { x := div(a,b) }
    function f2(a,b,c) -> x, y { x := f(a,b) }

و همه ارجاع به ``f`` را با ``f2`` جایگزین کنید. پس از آن خط داخلی باید اجرا شود تا مطمئن شوید که تمام 
ارجاعات به ``f2`` با ``f`` جایگزین شده است.


پیش نیازها: ابهام زدا، FunctionHoister، LiteralRematerialiser.

مرحله LiteralRematerialiser برای درستی مورد نیاز نیست. این کمک می کند تا با مواردی مانند: 

 ``function f(x) -> y { revert(y, y} }`` که در آن ``y`` لیترال با مقدار ``0`` جایگزین شود، به ما اجازه می دهد 
تا تابع را بازنویسی کنیم.


.. _equivalent-function-combiner:

EquivalentFunctionCombiner
^^^^^^^^^^^^^^^^^^^^^^^^^^
اگر دو تابع از نظر نحوی معادل باشند، در حالی که اجازه تغییر نام متغیر را می دهند، اما هیچ گونه ترتیب 
مجددی را نمی دهند، هر ارجاعی به یکی از توابع با دیگری جایگزین می شود.

حذف واقعی عملکرد توسط هرس استفاده نشده انجام می شود.




Inlining تابع (Function Inlining)
-----------------

.. _expression-inliner:

ExpressionInliner
^^^^^^^^^^^^^^^^^
این جزء از بهینه ساز، توابع محدود شده را با توابع درون خطی انجام می دهد که می توانند در داخل عبارات 
تابعی قرار بگیرند، یعنی توابعی که:


- یک مقدار واحد را برگردانید.
- بدنه‌ای مانند    ``r := <functional expression>``    داشته باشید.
- نه خود و نه ``r``  را در سمت راست ارجاع دهید.


علاوه بر این، برای همه پارامترها، تمام موارد زیر باید درست باشد:

- آرگومان قابل انتقال است.
- پارامتر یا کمتر از دو بار در بدنه تابع ارجاع داده می شود، یا آرگومان نسبتاً ارزان است ("هزینه" حداکثر 1، مانند ثابت تا 0xff).


 مثال: تابعی که قرار است درون خطی شود به شکل تابع ``function f(...) -> r { r := E }`` است که در آن ``E`` عبارتی 
است که به ``r`` ارجاع نمی دهد و همه آرگومان های فراخوانی تابع عبارت های قابل انتقال هستند. 

نتیجه این خط بندی همیشه یک عبارت واحد است.

این مؤلفه فقط در منابعی با نام های منحصر به فرد قابل استفاده است.

.. _full-inliner:

FullInliner
^^^^^^^^^^^

Full Inliner جایگزین تماس های خاصی از عملکردهای خاص توسط بدنه عملکرد می شود که در اکثر 
موارد خیلی مفید نیست، زیرا فقط اندازه کد را افزایش می دهد اما فایده ای ندارد. علاوه بر این، کد معمولاً 
بسیار گران است و ما اغلب ترجیح می‌دهیم کد کوتاه‌تری داشته باشیم تا کد کارآمدتر. اگرچه در موارد 
مشابه، درون‌سازی یک تابع می‌تواند اثرات مثبتی بر مراحل بهینه‌ساز بعدی داشته باشد. این در صورتی است 
که مثلا یکی از آرگومان های تابع ثابت باشد.




در طول Inline، از یک اکتشافی برای تشخیص اینکه آیا فراخوانی تابع باید خطی باشد یا نه استفاده 
می‌شود. اکتشافی فعلی در توابع "بزرگ" قرار نمی گیرد مگر اینکه تابع فراخوانی شده کوچک باشد. توابعی 
که فقط یک بار استفاده می شوند به صورت خطی هستند و همچنین توابع با اندازه متوسط، در حالی که 
فراخوانی تابع با آرگومان های ثابت امکان توابع کمی بزرگتر را می دهد.



در آینده، ممکن است یک مؤلفه Backtracking را اضافه کنیم که به‌جای اینکه یک تابع را فوراً درون خط 
قرار دهد، فقط آن را تخصصی می‌کند، به این معنی که یک کپی از تابع در جایی تولید می‌شود که یک 
پارامتر خاص همیشه با یک ثابت جایگزین می‌شود.
پس از آن، می توانیم بهینه ساز را روی این تابع تخصصی اجرا کنیم. اگر منجر به سودهای سنگین شود، 
عملکرد تخصصی حفظ می شود، در غیر این صورت عملکرد اصلی به جای آن استفاده می شود.




پاک کردن(Cleanup)
-------
پاکسازی در پایان اجرای بهینه ساز انجام می شود. سعی می کند عبارات تقسیم شده را دوباره به عبارات 
عمیق تو در تو ترکیب کند و همچنین "کامپایل پذیری" را برای ماشین ها با حذف متغیرها تا حد امکان 
بهبود می بخشد.


.. _expression-joiner:

ExpressionJoiner
^^^^^^^^^^^^^^^^
این عمل مخالف عبارت splitter است. دنباله ای از اعلان های متغیر که دقیقاً یک مرجع دارند را به یک 
عبارت پیچیده تبدیل می کند. این مرحله به طور کامل ترتیب فراخوانی های تابع و اجرای آپکدها 
را حفظ می کند. از هیچ اطلاعاتی در مورد قابلیت جابجایی آپکدها استفاده نمی کند. اگر انتقال 
مقدار یک متغیر به محل استفاده آن ترتیب فراخوانی هر تابع یا اجرای کد عملیاتی را تغییر دهد، تبدیل انجام 
نمی‌شود.


توجه داشته باشید که کامپوننت مقدار تخصیص داده شده یک انتساب متغیر را که بیش از یک بار به آن 
ارجاع داده شده است، جابه جا نمی کند.


قطعه ``let x := add(0, 2) let y := mul(x, mload(2))``  تبدیل نمی شود، زیرا باعث می شود ترتیب 
فراخوانی به آپکدها ``add`` و ``mload`` مبادله شود - حتی اگر این تفاوتی ایجاد نمی کند زیرا ``add`` 
قابل انتقال است. 


هنگام مرتب کردن مجدد آپکدها  مانند آن، ارجاعات متغیر و لیترال ها نادیده گرفته می شوند. به همین دلیل، 
قطعه    ``let x := add(0, 2) let y := mul(x, 3)``  به ``let y := mul(add(0, 2), 3)`` تبدیل می‌شود، حتی اگر 
 آپکد   ``add`` پس از ارزیابی لیترال   ``3`` اجرا شود.



.. _SSA-reverser:

SSAReverser
^^^^^^^^^^^

این یک گام کوچک است که در صورت ترکیب شدن با Common Subexpression Eliminator و 
Unused Pruner به معکوس کردن اثرات تبدیل SSA کمک می کند. 

فرم SSA که تولید می کنیم برای تولید کد در EVM و WebAssembly به طور یکسان مضر است زیرا 
متغیرهای محلی زیادی تولید می کند. بهتر است فقط از متغیرهای موجود با انتساب به جای اعلان متغیرهای 
تازه استفاده مجدد شود.

 تبدیل SSA بازنویسی می کند.


.. code-block:: yul

    let a := calldataload(0)
    mstore(a, 1)

to

.. code-block:: yul

    let a_1 := calldataload(0)
    let a := a_1
    mstore(a_1, 1)
    let a_2 := calldataload(0x20)
    a := a_2



مشکل این است که به جای ``a`` ، هر زمان که ``a`` ارجاع داده شد از متغیر ``a_1`` استفاده می شود. تبدیل SSA
عبارات این فرم را تنها با تعویض اعلان و تخصیص تغییر می دهد. قطعه بالا تبدیل شده است



.. code-block:: yul

    let a := calldataload(0)
    let a_1 := a
    mstore(a_1, 1)
    a := calldataload(0x20)
    let a_2 := a



این یک تبدیل هم ارزی بسیار ساده است، اما وقتی اکنون حذف کننده مشترک Subexpression را اجرا
 می کنیم، همه رخدادهای ``a_1``   را با    ``a``  جایگزین می کند (تا زمانی که  ``a``  دوباره اختصاص داده شود). سپس 
Pruner استفاده نشده متغیر   ``a_1``   را به طور کلی حذف می کند و بنابراین تبدیل SSA را کاملاً معکوس می 
کند.


.. _stack-compressor:

StackCompressor
^^^^^^^^^^^^^^^

یکی از مشکلاتی که تولید کد برای ماشین مجازی اتریوم را سخت می کند، این واقعیت است که محدودیت 
سختی از 16 اسلات برای رسیدن به stack عبارت وجود دارد. این کم و بیش به محدودیت 16 متغیر محلی 
ترجمه می شود. کمپرسور stack کد Yul را می گیرد و آن را به بایت کد EVM کامپایل می کند. هر زمان 
که اختلاف stack خیلی زیاد باشد، عملکردی که در آن اتفاق افتاده را ثبت می کند.

برای هر تابعی که چنین مشکلی را ایجاد می کند، Rematerialiser با یک درخواست خاص فراخوانی می 
شود تا متغیرهای خاصی را که بر اساس هزینه مقادیر آنها مرتب شده اند، حذف کند.

 در صورت شکست، این روش چندین بار تکرار می شود.


.. _rematerialiser:

Rematerialiser
^^^^^^^^^^^^^^

مرحله مادی‌سازی یا ematerialisation مجدد سعی می‌کند تا ارجاعات متغیر را با عبارتی که آخرین بار 
به متغیر اختصاص داده شده است، جایگزین کند.
البته این تنها زمانی مفید است که ارزیابی این عبارت نسبتاً ارزان باشد. علاوه بر این، تنها زمانی معادل معنایی 
است که مقدار عبارت بین نقطه تخصیص و نقطه استفاده تغییر نکرده باشد. مزیت اصلی این مرحله این است 
که اگر منجر به حذف کامل یک متغیر شود، می‌تواند اسلات‌های stack را ذخیره کند (پایین را ببینید)، اما 
اگر عبارت بسیار ارزان باشد، می‌تواند یک اپکد DUP را نیز در EVM ذخیره کند.

Rematerialiser از Dataflow Analyzer برای ردیابی مقادیر جاری متغیرها استفاده می کند که 
همیشه قابل انتقال هستند. اگر مقدار بسیار ارزان باشد یا به صراحت از متغیر درخواست شده باشد که حذف 
شود، مرجع متغیر با مقدار فعلی آن جایگزین می شود.


.. _for-loop-condition-out-of-body:

ForLoopConditionOutOfBody
^^^^^^^^^^^^^^^^^^^^^^^^^

 تبدیل ForLoopConditionIntoBody را معکوس می کند. برای هر  ``c``   قابل انتقال، تبدیل می شود 


.. code-block:: none

    for { ... } 1 { ... } {
    if iszero(c) { break }
    ...
    }

به

.. code-block:: none

    for { ... } c { ... } {
    ...
    }

و تبدیل می شود

.. code-block:: none

    for { ... } 1 { ... } {
    if c { break }
    ...
    }

به

.. code-block:: none

    for { ... } iszero(c) { ... } {
    ...
    }

LiteralRematerialiser باید قبل از این مرحله اجرا شود.



وب اسمبلی خاص
--------------------

عملکرد اصلی
^^^^^^^^^^^^

بالاترین بلوک را به تابعی با نام خاص ("main") تغییر می دهد که ورودی و خروجی ندارد.

 بستگی به Function Grouper دارد.

