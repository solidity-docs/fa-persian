.. _security_considerations:

##############
ملاحظات امنیتی
##############

درحالیکه معمولاً ساختن نرم‌افزاری که مطابق انتظارات عمل کند آسان است، بررسی اینکه کسی نتواند از آن به نحو غیرقابل پیشبینی‌شده‌ای سوء استفاده کند بسیار دشوارتر است.  

در سالیدیتی این امر حتی مهمتر است زیرا قراردادهای هوشمند می‌توانند به منظور مدیریت توکن‌ها یا حتی چیزهایی باارزش‌تر استفاده شوند. علاوه بر آن هر عملی که توسط یک قرارداد هوشمند صورت گیرد عمومی‌ست و گذشته از این، `کد منبع <https://fa.wikipedia.org/wiki/%DA%A9%D8%AF_%D9%85%D9%86%D8%A8%D8%B9>`_ غالباً در دسترس عام است.

البته همواره باید در نظر گرفته شود که چه مقدار ریسک در گرو است:
می‌توان یک قرارداد هوشمند را با یک `خدمت وب <https://fa.wikipedia.org/wiki/%D8%AE%D8%AF%D9%85%D8%AA_%D9%88%D8%A8>`_ (وب سرویس، web service) مقایسه کرد که برای عموم (متعاقباً برای عوامل مخرب) آزاد بوده و احتمالاً `متن‌باز <https://fa.wikipedia.org/wiki/%D9%85%D8%AA%D9%86%E2%80%8C%D8%A8%D8%A7%D8%B2>`_ نیز است. اگر فقط لیست مواد غذایی خود را در آن وب سرویس ذخیره کنید شاید نیازی به مراقب بیش از حد نداشته باشید، ولی اگر حساب بانکی خود را با استفاده از آن وب سرویس مدیریت می‌کنید، باید بیشتر مواظب باشید. 

این بخش فهرستی از برخی تله‌های مشکل‌آفرین و توصیه‌های امنیتی کلی است ولیکن مشخصاً هیچگاه نمی‌تواند کامل باشد. همچنین به خاطر داشته باشید که هرچند کد شما می‌تواند عاری از اشکال (bug) باشد، ولی ممکن است کامپایلر یا خودِ پلتفرم دارای باگ باشد. فهرستی از برخی اشکالات امنیتی مرتبط با کامپایلر که بصورت عمومی شناخته شده‌اند را می‌توانید در :ref:`فهرست باگ‌های شناخته شده<known_bugs>` که `ماشین‌خوانا <https://fa.wikipedia.org/wiki/%D8%B1%D8%B3%D8%A7%D9%86%D9%87_%D9%85%D8%A7%D8%B4%DB%8C%D9%86%E2%80%8C%D8%AE%D9%88%D8%A7%D9%86%D8%A7>`_ نیز است، بیابید. قابل ذکر است که یک `برنامهٔ باگ باونتی <https://fa.wikipedia.org/wiki/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87_%D8%A8%D8%A7%DA%AF_%D8%A8%D8%A7%D9%88%D9%86%D8%AA%DB%8C>`_ نیز وجود دارد که مولد کد کامپایلر سالیدیتی را تحت پوشش قرار می‌دهد.

طبق روال مستندات متن‌باز از شما درخواست می‌شود که به ما در توسعهٔ این بخش یاری دهید (مخصوصاً اضافه کردن چند مثال ضرری ندارد!)

توجه: علاوه بر فهرست زیر شما می‌توانید توصیه‌های امنیتی و شگردهای بیشتری در `Guy Lando's knowledge list <https://github.com/guylando/KnowledgeLists/blob/master/EthereumSmartContracts.md>`_ و `Consensys GitHub repo <https://consensys.github.io/smart-contract-best-practices/>`_ بیابید.

******
تله‌ها
******

اطلاعات خصوصی و تصادفیدگی
=========================

هرچیزی که در یک قرارداد هوشمند استفاده شود بصورت عمومی قابل مشاهده است، حتی متغیرهای محلی (local) و حالت (state) که با ``private`` علامت‌گذاری شده باشند.

استفاده از `اعداد تصادفی <https://fa.wikipedia.org/wiki/%D8%A7%D8%B9%D8%AF%D8%A7%D8%AF_%D8%AA%D8%B5%D8%A7%D8%AF%D9%81%DB%8C>`_ در قراردادهای هوشمند می‌تواند بسیار دشوار باشد چراکه سازندگان بلاک در این حالت می‌توانند تقلب کنند.

بازدُخولی (Reentrancy)
=====================

هرگونه تعاملی از یک قرارداد (A) با قراردادی دیگر (B)، و هرگونه انتقال اتر، کنترل را به آن قرارداد (B) تحویل می‌دهد. این انتقال کنترل به B امکان می‌دهد که A را قبل از تکمیل تعامل فراخوانی کند. برای مثال، کد زیر را که حاوی باگ است در نظر بگیرید (این کد فقط یک قطعه بوده و یک قرارداد کامل نیست):

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.6.0 <0.9.0;

    // THIS CONTRACT CONTAINS A BUG - DO NOT USE
    contract Fund {
        /// @dev Mapping of ether shares of the contract.
        mapping(address => uint) shares;
        /// Withdraw your share.
        function withdraw() public {
            if (payable(msg.sender).send(shares[msg.sender]))
                shares[msg.sender] = 0;
        }
    }

مشکل در اینجا بدلیل محدود بودن گاز بعنوان جزئی از ``send`` زیاد جدی نیست، با این وجود همچنان ضعف وجود دارد: انتقال اتر همیشه می‌تواند شامل اجرای کد باشد، بنابراین دریافت‌کننده می‌تواند قراردادی باشد که توانایی بازفراخوانی ``withdraw`` را دارد که به آن اجازهٔ دریافت چندین بازپرداخت و اساساً تمام اتر موجود در قرارداد را می‌دهد. به ویژه قرارداد زیر به مهاجم امکان بازپرداخت چندباره را می‌دهد، چراکه از ``call``، که بطور پیش‌فرض تمام گاز باقی‌مانده را ارسال می‌کند، استفاده شده است. 

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.6.2 <0.9.0;

    // THIS CONTRACT CONTAINS A BUG - DO NOT USE
    contract Fund {
        /// @dev Mapping of ether shares of the contract.
        mapping(address => uint) shares;
        /// Withdraw your share.
        function withdraw() public {
            (bool success,) = msg.sender.call{value: shares[msg.sender]}("");
            if (success)
                shares[msg.sender] = 0;
        }
    }

به منظور جلوگیری از `بازدُخولی <https://fa.wikipedia.org/wiki/%D8%A8%D8%A7%D8%B2%D8%AF%D8%AE%D9%88%D9%84%DB%8C>`_ شما می‌توانید از الگوی بررسی‌ها-اثرات-تعاملات (Checks-Effects-Interactions) بصورتیکه در زیر نشان داده شده است استفاده کنید:

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.6.0 <0.9.0;

    contract Fund {
        /// @dev Mapping of ether shares of the contract.
        mapping(address => uint) shares;
        /// Withdraw your share.
        function withdraw() public {
            uint share = shares[msg.sender];
            shares[msg.sender] = 0;
            payable(msg.sender).transfer(share);
        }
    }

الگوی بررسی‌ها-اثرات-تعاملات تضمین می‌کند که تمامی مسیرهای کدِ سرتاسر یک قرارداد قبل از تغییر حالت (state) آن، همهٔ بررسی‌های لازمهٔ پارامترهای ارائه شده را تکمیل کنند (بررسی‌ها)؛ تنها پس از این بررسی‌ها هرگونه تغییری در حالت را اعمال کنند (اثرات)؛ و نهایتاً فراخوانی توابع از قراردادهای دیگر فقط زمانی صورت گیرد که همهٔ تغییرات حالت برنامه‌ریزی شده ذخیره شده باشند (تعاملات). این یک روش محافظه‌کارانهٔ رایج برای مقابله با حملات بازدُخولی است، حملاتی که در آن یک قرارداد مخرب با استفاده از منطق فراخوانیِ قرارداد اصلی قبل از تکمیل تراکنش، توانایی `دوبار خرج کردن <https://fa.wikipedia.org/wiki/%D8%AF%D9%88%D8%A8%D8%A7%D8%B1_%D8%AE%D8%B1%D8%AC_%DA%A9%D8%B1%D8%AF%D9%86>`_ مستمری، دوبار بازگیری تتمهٔ حساب، و حملات مشابه را دارد.

توجه داشته باشید که بازدخولی نه تنها بر انتقال اتر، بلکه بر روی هر فراخوانی از توابع قراردادهای دیگر تأثیر دارد. علاوه بر این شما باید شرایط چندقراردادی را نیز در نظر داشته باشید. یک قرارداد فراخوانی شده می‌تواند حالت قراردادی دیگر را که به آن وابسته‌اید، تغییر دهد.

محدودیت گاز و حلقه‌ها
====================

از حلقه‌هایی که تعداد تکرار مشخص و ثابتی ندارند، مثلاً حلقه‌هایی که به مقادیر ذخیره شده وابسته‌اند، بایستی با دقت استفاده کرد:
با توجه به محدودیت گاز بلوک، تراکنش‌ها می‌توانند تنها مقدار مشخصی گاز مصرف کنند. صراحتاً، یا صرفاً بدلیل عملکرد عادی، تعداد تکرارها در یک حلقه می‌تواند به مقداری فراتر از حد گاز بلوک افزایش یافته و متعاقباً باعث توقف کل قرارداد در نقطه‌ای معین شود. این خاصیت شامل توابع ``view`` نمی‌شود چراکه این توابع تنها به منظور خواندن داده‌ها از بلاکچین استفاده می‌شوند. با این حال چنین توابعی همچنین می‌توانند توسط قراردادهای دیگر بعنوان بخشی از عملیات زنجیره‌ای فراخوانی شده و باعث توقف آنها شوند. لطفاً در مستندات قراردادهای خود در مورد استفاده از چنین مواردی توسط دیگران، صریح باشید. 

ارسال و دریافت اتر
===================

- در حال حاظر نه قراردادها و نه «حساب‌های خارجی» توانایی ممانعت از دریافت اتر ارسالی توسط دیگران را ندارند.
  قراردادها می‌توانند به یک انتقال متداول واکنش نشان داده و آنرا رد کنند، لکن راه‌هایی برای انتقال اتر بدون ایجاد پیام وجود دارد. یکی از راه‌ها این است که بسادگی آدرس قرارداد را استخراج کنند و راه دوم استفاده از ``selfdestruct(x)`` است.
  
- اگر قراردادی (بدون فراخوانی هیچ تابعی) اتر دریافت کند یکی از توابع :ref:`receive Ether <receive-ether-function>` یا :ref:`fallback <fallback-function>` اجرا می‌شود.
  اگر این قرارداد تابع دریافت یا عقب‌نشینی (fallback) نداشته باشد، اتر دریافتی (با پرتاب یک استثنا) رد می‌شود. در حین اجرای یکی از این توابع، قرارداد فقط می‌تواند به «دستمزد گاز» که در اختیارش قرار گرفته (۲۳۰۰ گاز) و در آن زمان در دسترسش است، متکی باشد. این دستمزد برای تغییر فضای ذخیره‌سازی کافی نیست (این موضوع را سهل نگیرید چراکه مقدار دستمزد گاز ممکن است در `هارد فورک‌های <https://fa.wikipedia.org/wiki/%D9%81%D9%88%D8%B1%DA%A9_(%D8%B2%D9%86%D8%AC%DB%8C%D8%B1%D9%87_%D8%A8%D9%84%D9%88%DA%A9%DB%8C)#%D9%87%D8%A7%D8%B1%D8%AF_%D9%81%D9%88%D8%B1%DA%A9>`_ آینده تغییر کند). برای اطمینان از اینکه قرارداد شما می‌تواند اتر را به این طریق دریافت کند لزومات گاز تابع دریافت و تاب عقب‌نشینی (fallback) را بررسی کنید (برای مثال بخش «جزئیات» را در Remix ببینید).
  
- راهی برای رساندن گاز بیشتر به قرارداد دریافت کننده با استفاده از ``addr.call{value: x}("")`` وجود دارد. این اساساً همانند ``addr.transfer(x)`` عمل می‌کند تنها با این تفاوت که تمام گاز مازاد را ارسال می‌کند و امکان انجام اعمال گرانتر را برای گیرنده فراهم می‌آورد (و بجای انتشار خودکار خطا، یک کد شکست یا همان عدم موفقیت را برمی‌گرداند). این ممکن است شامل بازفراخوانی به قرارداد ارسال کننده یا تغییرات وضعیتی دیگری باشد که به آن توجه نکرده بودید. بدین‌سبب، این راه انعطاف‌پذیری زیادی برای کاربران عادل و همچنین بازیگران مخرب اعطاء می‌کند.

- از دقیق‌ترین واحدها برای نشان دادن مقدار wei استفاده کنید زیرا هرچه که از روی عدم دقت گرد شده باشد، از دست خواهد رفت.

- اگر می‌خواهید اتر را با استفاده از ``address.transfer`` ارسال کنید جزئیات خاصی وجود دارند که باید از آنها آگاه باشید:

  1. اگر گیرنده یک قرارداد باشد، باعث می شود تابع دریافت یا عقب‌نشینی آن اجرا شود که به نوبهٔ خود می تواند قرارداد ارسالی را فراخوانی کند.
  2. ارسال اتر ممکن است به دلیل عمق تماس بالاتر از ۱۰۲۴ با شکست مواجه شود. از آنجاییکه تماس گیرنده کنترل کاملِ عمق تماس دارد می‌تواند انتقال را وادار به شکست کند؛ شما می‌توانید این احتمال را لحاظ کنید یا از ``send`` استفاده کرده و توجه داشته باشید که مقدار بازگشتی همواره بررسی می‌شود. یا حتی بهتر از آن، قرارداد خود را با استفاده از الگویی بنویسید که گیرنده توانایی بازگیری (withdraw) اتر را داشته باشد.
  3. همچنین ارسال اتر ممکن است به این دلیل با شکست مواجه شود که قرارداد دریافت کننده مقداری بیش از میزانِ گازِ اختصاص داده شده درخواست کند (یا صراحتاً با استفاده از :ref:`require <assert-and-require>` یا :ref:`assert <assert-and-require>` یا :ref:`revert <assert-and-require>` و یا گران بودن بیش از حدِ عملیات) - «گاز تمام شده است» (it runs out of gas, OOG). اگر از ``transfer`` یا ``send`` بهمراه بررسیِ مقدارِ برگشتی استفاده کنید ممکن است راهی برای گیرنده ایجاد شود تا پیشرفت قرارداد ارسالی را مسدود کند. مجدداً لازم به ذکر است که بهترین راهکار در اینجا نیز استفاده از یک :ref:`الگوی "withdraw" بجای الگوی "send" است <withdrawal_pattern>`.

عمق پشتهٔ تماس (Call Stack Depth)
================================

فراخوانی توابع خارجی هر لحظه ممکن است با شکست روبرو شود چراکه این فراخوانی‌ها از حداکثر اندازهٔ `پشتهٔ تماس <https://fa.wikipedia.org/wiki/%D9%BE%D8%B4%D8%AA%D9%87_%D8%AA%D9%85%D8%A7%D8%B3>`_ که ۱۰۲۴ است تجاوز می‌کنند. در چنین مواقعی سالیدیتی یک استثنا پرتاب می‌کند. بازیگران مخرب ممکن است بتوانند قبل از اینکه با قرارداد شما تعاملی داشته باشند، پشتهٔ تماس را وادار به افزایش به مقدار بالایی کنند. توجه داشته باشید که پس از هاردفورکِ `Tangerine Whistle <https://eips.ethereum.org/EIPS/eip-608>`_، `قانون ۶۳/۶۴ <https://eips.ethereum.org/EIPS/eip-150>`_ حملهٔ عمق پشتهٔ تماس را غیرعملی کرده است. همچنین قابل ذکر است که پشتهٔ تماس (call stack) و پشتهٔ عبارت (expression stack) ارتباطی باهم ندارند هرچند هردو دارای محدودیت اندازهٔ ۱۰۲۴ `اسلات <https://fa.wikipedia.org/wiki/%D8%A7%D8%B3%D9%84%D8%A7%D8%AA_(%D9%85%D8%B9%D9%85%D8%A7%D8%B1%DB%8C_%DA%A9%D8%A7%D9%85%D9%BE%DB%8C%D9%88%D8%AA%D8%B1)>`_ پشته هستند.

توجه داشته باشید که ``.send()`` در صورتیکه پشتهٔ تماس خالی شود استثنایی پرتاب **نمی‌کند** بلکه در آن حالت ``false`` برمی‌گرداند. توابع سطح پایین ``.call()``، ``.delegatecall()`` و ``.staticcall()`` به همین روال رفتار می‌کنند.

پروکسی‌های مجاز
==============

اگر قرارداد شما می‌تواند بعنوان یک پروکسی عمل کند، یعنی اگر بتواند هر قرارداد دلخواهی را با داده‌های ارائه شده توسط کاربر فراخوانی کند، آن کاربر اساساً می‌تواند هویت قرارداد پروکسی را تقلید کند. حتی اگر از اقدامات حفاظتی دیگری نیز استفاده کرده باشید بهتر است سیستم قرارداد خود را طوری بسازید که پروکسی هیچ مجوزی (حتی برای خودش) نداشته باشد. درصورت نیاز می‌توانید با استفاده از یک پروکسی دوم به این امر دست یابید: 

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity ^0.8.0;
    contract ProxyWithMoreFunctionality {
        PermissionlessProxy proxy;

        function callOther(address addr, bytes memory payload) public
                returns (bool, bytes memory) {
            return proxy.callOther(addr, payload);
        }
        // Other functions and other functionality
    }

    // This is the full contract, it has no other functionality and
    // requires no privileges to work.
    contract PermissionlessProxy {
        function callOther(address addr, bytes memory payload) public
                returns (bool, bytes memory) {
            return addr.call(payload);
        }
    }

متغیر سراسری tx.origin
======================

هرگز از tx.origin بعنوان مجوز استفاده نکنید. برای مثال فرض کنید یک قرارداد کیف پول مانند این دارید:

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.7.0 <0.9.0;
    // THIS CONTRACT CONTAINS A BUG - DO NOT USE
    contract TxUserWallet {
        address owner;

        constructor() {
            owner = msg.sender;
        }

        function transferTo(address payable dest, uint amount) public {
            // THE BUG IS RIGHT HERE, you must use msg.sender instead of tx.origin
            require(tx.origin == owner);
            dest.transfer(amount);
        }
    }

اکنون فردی شما را فریب می‌دهد تا مقداری اتر به آدرس این کیف پولِ حمله ارسال کنید:

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.7.0 <0.9.0;
    interface TxUserWallet {
        function transferTo(address payable dest, uint amount) external;
    }

    contract TxAttackWallet {
        address payable owner;

        constructor() {
            owner = payable(msg.sender);
        }

        receive() external payable {
            TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);
        }
    }

اگر کیف پول شما ``msg.sender`` را برای صدور جواز بررسی کرده بود، بجای آدرس مالک آدرسی کیف پول حمله را دریافت می‌کرد. اما با بررسی ``tx.origin`` آدرس اصلی، که آغاز کنندهٔ تراکنش بود، را دریافت می‌کند، که همچنان آدرس مالک است. کیف پول حمله بلافاصله تمام سرمایهٔ شما را تخلیه می‌کند.

.. _underflow-overflow:

مکمل دو \ سرریز \ کمبود
=========================================

در سالیدیتی، همانند بسیاری از زبان‌های برنامه‌نویسی، `انواع <https://fa.wikipedia.org/wiki/%D9%86%D9%88%D8%B9_%D8%AF%D8%A7%D8%AF%D9%87>`_ عدد صحیح در واقع اعداد صحیح نیستند. وقتی مقادیر کوچک باشند اعداد صحیح را تشبیه می‌کنند، ولی نمی‌توانند هر عدد بزرگ دلخواه را نمایش دهند. 

کد زیر باعث `سرریزی <https://fa.wikipedia.org/wiki/%D8%B3%D8%B1%D8%B1%DB%8C%D8%B2_%D8%B9%D8%AF%D8%AF_%D8%B5%D8%AD%DB%8C%D8%AD>`_ می‌شود، زیرا نتیجه عمل جمع برای ذخیره شدن در نوع ``uint8`` بیش‌ازحد بزرگ است:

.. code-block:: solidity

  uint8 x = 255;
  uint8 y = 1;
  return x + y;

سالیدیتی دارای دو حالت است که در آن با این سرریزها سروکار دارد: چک‌شده (Checked) و چک‌نشده (Unchecked) یا حالت «بسته‌بندی» (wrapping).

حالت پیش‌فرض چک‌شده سرریزها را تشخیص داده و باعث عدم موفقیت در تصدیق می‌شود. شما می‌توانید این بررسی را با استفاده از ``unchecked {...}`` غیرفعال نمایید، که این امر باعث می‌شود سرریزی بطور بی‌صدا نادیده گرفته شود. کد بالا اگر با ``unchecked {...}`` پیچیده شود، ``0`` برمی‌گرداند.

حتی در حالت چک‌شده تصور نکنید که از باگ‌های سرریز در امان هستید. در این حالت سرریزها همیشه بازگشت داده می‌شوند. اگر امکان جلوگیری از سرریز وجود نداشته باشد، این امر می‌تواند منجر به گیر کردن قرارداد هوشمند در حالت خاصی شود.

بطور کلی بهتر است راجع به محدودیت‌های نمایش `مکمل دو <https://fa.wikipedia.org/wiki/%D9%85%DA%A9%D9%85%D9%84_%D8%AF%D9%88>`_، که حتی موارد لبه‌ای خاص‌تری برای اعداد علامت‌دار دارند، بخوانید.

سعی کنید از ``require`` به منظور محدود کردن اندازهٔ ورودی‌ها به یک حوزهٔ مناسب و از :ref:`SMT checker<smt_checker>` برای یافتن سرریزهای احتمالی استفاده کنید.

.. _clearing-mappings:

پاک کردن نگاشت‌ها (Mappings)
==========================

نگاشت (``mapping``، در :ref:`mapping-types` بیشتر بخوانید) بعنوان نوعِ (type) سالیدیتی یک ساختمان دادهٔ مخصوص ذخیره‌سازی و `کلید-مقدار <https://fa.wikipedia.org/wiki/%D9%BE%D8%A7%DB%8C%DA%AF%D8%A7%D9%87_%D8%AF%D8%A7%D8%AF%D9%87_%DA%A9%D9%84%DB%8C%D8%AF%E2%80%93%D9%85%D9%82%D8%AF%D8%A7%D8%B1>`_ است که کلیدهایی را که مقدار غیرصفر به آنها اختصاص داده شده، پیگیری نمیکند. به همین خاطر تمیز کردن یک نگاشت بدون اطلاعات اضافی درمورد کلیدهای نوشته شده، جایز نیست.
اگر یک ``mapping`` بعنوان نوع پایهٔ یک آرایه با ذخیره‌سازیِ پویا استفاده شود، حذف کردن یا پاپ کردن (popping) آرایه هیچ تأثیری روی اعضای نگاشت نخواهد گذاشت. برای مثال اگر یک ``mapping`` بعنوان نوعی از فیلدِ عضو یک ``struct`` استفاده شود که خود نوع پایهٔ یک آرایهٔ ذخیره‌سازیِ پویا باشد، باز همین اتفاق رخ می‌دهد. نگاشت همچنین در تخصیص ساختارها یا آرایه‌هایی که خود حاوی نگاشت باشند، نادیده گرفته می‌شود.

.. code-block:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.6.0 <0.9.0;

    contract Map {
        mapping(uint => uint)[] array;

        function allocate(uint newMaps) public {
            for (uint i = 0; i < newMaps; i++)
                array.push();
        }

        function writeMap(uint map, uint key, uint value) public {
            array[map][key] = value;
        }

        function readMap(uint map, uint key) public view returns (uint) {
            return array[map][key];
        }

        function eraseMaps() public {
            delete array;
        }
    }

مثال بالا و این دنباله از فراخوانی‌ها را در نظر بگیرید: ``allocate(10)``، ```writeMap(4, 128, 256)``. در این مرحله فراخوانیِ ``readMap(4, 128)`` عدد 256 را برمی‌گرداند. اگر ``eraseMaps`` را فراخوانی کنیم طول متغیر حالت ``array`` صفر می‌شود ولی از آنجاییکه نمی‌توان اعضای نگاشتِ آنرا صفر کرد، اطلاعات آنها در مخزنِ قرارداد، زنده می‌مانند. پس از حذف ``array``، فراخوانی ``allocate(5)`` به ما امکان دسترسی دوباره به ``array[4]`` را می‌دهد و فراخوانی ``readMap(4, 128)`` عدد 256 را، حتی بدون فراخوانی دوبارهٔ ``writeMap``، برمی‌گرداند.

اگر اطلاعات ``mapping`` شما بایستی حذف شود، استفاده از کتابخانه‌ای مانند `iterable mapping <https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol>`_ را در نظر داشته باشید چراکه به شما در یک نگاشت مناسب، امکان پیمودن کلیدها و حذف کردن مقدارشان را فراهم می‌آورد.

جزئیات کوچک
============

- نوع‌هایی که ۳۲ بیت را بصورت کامل اشغال نمی‌کنند ممکن است حاوی «بیت‌های کثیف از مرتبهٔ بالاتر» باشند. این امر به‌ویژه زمانی مهم است که از دسترسی به ``msg.data`` استفاده کنید - که ریسک قابلیت انعطاف را بهمراه دارد: بعنوان مثال می‌توانید تراکنش‌هایی ایجاد کنید که تابع ``f(uint8 x)`` را با آرگومان بایت خام ``0xff000001`` و ``0xff000001`` فراخوانی کنند. هردو به قرارداد داده می‌شوند و هردو تاجاییکه به ``x`` مربوط باشد مانند عدد ``1`` بنظر می‌آیند، درحالیکه ``msg.data`` متفاوت است؛ پس اگر از ``keccak256(msg.data)`` استفاده کنید، نتایج گوناگونی دریافت خواهید کرد.

*******
توصیه‌ها
*******

هشدارها را جدی بگیرید
=====================

اگر کامپایلر در مورد چیزی به شما هشدار (warning) داد باید آنرا تغییر دهید. حتی اگر فکر نمی‌کنید که این هشدار خاص پیامدهای امنیتی داشته باشد، این امکان وجود دارد که مشکل دیگری پشت آن پنهان باشد. هر اخطار کامپایلری که ما صادر می‌کنیم می‌تواند با تغییرات جزئی در کد به حالت بی‌صدا درآید.

همواره از آخرین نسخهٔ کامپایلر استفاده کنید تا از همهٔ هشدارهایی که اخیراً صادر شده‌اند مطلع شوید.

پیام‌هایی که از نوع ``info`` توسط کامپایلر صادر شده‌اند خطرناک نیستند و صرفاً پیشنهادات اضافی و اطلاعات اختیاری را نشان می‌دهند که کامپایلر فکر می‌کند ممکن است برای کاربر مفید باشند. 

مقدار اتر را محدود کنید
=======================

مقدار اتر (یا توکن‌های دیگر) را که می‌توان در یک قرارداد هوشمند ذخیره کرد، محدود کنید. اگر کد منبع، کامپایلر، یا پلتفرم دارای باگ باشد این سرمایه ممکن است از بین برود. با محدود سازی مقدار اتر، ضرر خود را محدود کنید.

قرارداد را کوچک و ماژولی نگه دارید
==================================

قراردادهای خود را کوچک و طوری که به آسانی قابل درک باشند، نگه دارید. عملکردهای نامربوط را جداگانه در قراردادهای دیگر یا کتابخانه‌ها نگهداری نمایید. توصیه‌های کلی دربارهٔ کیفیت کدِ منبع مسلماً قابل اعمال هستند: مقدار متغیرهای محلی، طول توابع و غیره را محدود کنید. توابع خود را مستند کنید تا دیگران هدف و قصد شما را دیده و اگر تفاوتی بین اسناد و آنچه که کد انجام می‌دهد وجود داشته باشد را آشکار کنند.

از الگوی بررسی‌ها-اثرات-تعاملات استفاده کنید
==========================================

اکثر توابع ابتدا برخی از بررسی‌ها را بجا می‌آورند (چه کسی تابع را فراخوانی کرد، آیا آرگومان‌ها در محدوده هستند، آیا اتر کافی ارسال کرده‌اند، آیا فرد توکن دارد، ...). این بررسی‌ها باید اول از همه انجام شوند.

پس از اینکه همهٔ بررسی‌ها گذرانده شدند، بعنوان گام دوم، تأثیرات می‌توانند روی قرارداد جاری اعمال شوند. تعامل با سایر قراردادها باید بعنوان آخرین مرحله در هر تابعی اعمال شود.

قراردادهای اولیه برخی از اثرات را به تعویق می‌انداختند و منتظر فراخوانی‌هایی توسط تابع خارجی می‌شدند. بدلیل مشکل بازدُخولی که در بالا به آن پرداخته شده، این غالباً یک اشتباه جدی به حساب می‌آید.

همچنین توجه داشته باشید که فراخوانی به قراردادهای شناخته شده ممکن است به نوبهٔ خود باعث ایجاد فراخوانی به قراردادهای ناشناخته شود. بنابراین بهتر است که همیشه از این الگو پیروی کنید.

یک حالت شکست امن قرار دهید
==========================

درحالیکه غیرمتمرکز کردن سیستم بطور کامل، هرگونه واسطه‌ای را از میان می‌برد، شاید قرار دادن نوعی مکانیسم `شکست امن <https://fa.wikipedia.org/wiki/%D8%B4%DA%A9%D8%B3%D8%AA_%D8%A7%D9%85%D9%86>`_، مخصوصاً برای کد جدید، ایدهٔ خوبی باشد:

شما می‌توانید تابعی را به قرارداد هوشمند خود اضافه کنید که برخی از بررسی‌ها را بصورت خودآزمایی انجام دهد، مثلاً «آیا اتری نشت کرده است؟»، «آیا مجموع توکن‌ها با موجودی قرارداد برابر است؟»، یا مواردی از این قبیل. بخاطر داشته باشید که نمی‌توانید بیش از حد گاز برای این منظور استفاده کنید، پس یاری گرفتن از محاسبات جایی خارج از زنجیره (off-chain) ممکن است نیاز باشد.

اگر خودآزمایی با شکست مواجه شود قرارداد بصورت خودکار به نوعی حالت «شکست امن» تغییر می‌کند، که برای مثال اکثر ویژگی‌ها را غیرفعال کرده، کنترل را به شخص ثالثی که ثابت و قابل اعتماد است واگذار می‌کند، یا اینکه قرارداد را به یک قرارداد ساده‌ای مانند «پولم را پس بده» تبدیل می‌کند.

از دوست خود درخواست بررسی کنید
================================

هرچه افراد بیشتری یک قطعه کد را بررسی کنند مشکلات بیشتری کشف می‌شوند. همچنین درخواست از دیگران برای مرور کد به شما امکان بررسی متقابل را می‌دهد که باعث می‌شود دریابید آیا به آسانی قابل درک است یا نه - معیاری بسیار مهم برای قراردادهای هوشمند خوب.
